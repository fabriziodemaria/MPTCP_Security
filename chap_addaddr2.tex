\chapter{Fixing ADD\_ADDR}
\label{chap:addaddr2}

\section{The ADD\_ADDR2 format}
There is an ongoing effort to move the current MPTCP specification \rfc{6824} from Experimental to Standard Track. Solving the ADD\_ADDR vulnerability is believed to be a fundamental step to reach the required security standards for the transition to happen.
By analyzing the nature of the vulnerability, various proposals have been elaborated to modify the design of the ADD\_ADDR option [\rfc{7430}]. The conceptual flaw behind the option is that no secret material related to the ongoing MPTCP is included. The only security mechanism connected to such message is the TCP-level sequence and acknowledge numbers, that an attacker has to know in order to inject such message into an ongoing session.
A possible solution could be to add the receiver token of the connection as a field in the ADD\_ADDR option. Such token, exchanged only during connection establishment via the MP\_CAPABLE option, is supposed to be unknown to the attacker that in turns would not be able to forge a valid ADD\_ADDR message. This solution wouldn't be effective if the attacker is able to eavesdrop the keys during the initial handshake; keys' eavesdrop is indeed a security concern related to MPTCP and for this reason it is not advisable to add such information in clear inside the ADD\_ADDR option, since that would give more opportunities for eavesdropping.
Another possibility would be to maintain the ADD\_ADDR format unchanged but to block the attack at a later stage. For example, if the destination address of the SYN packet is added as part of the message used to calculate the HMAC value, the attacker wouldn't be able to recompute the HMAC value after modifying the destination address. However, since addresses are not a stable piece of information in a network with NATs, using the destination address to calculate the HMAC is not a viable solution.
In order to achieve higher security levels maintaining NAT compatibility, a third option has been proposed with positive feedback. The idea is to add to the ADD\_ADDR option a new field containing the truncated HMAC value (rightmost 64 bits) calculated as follow: the \textit{key} is the MPTCP key of the sender as originally agreed in the MP\_CAPABLE handshake; the \textit{message} is the concatenation of the previous three fields in packet: Address ID, advertised IP address, and Port. The new format (figure \ref{fig:addaddr2}) has been formally specified for the first time in \rfc{6824bis-04}, but a slight modification is proposed and introduced in \rfc{6824bis-05}, as explained in the following sections. For our analysis, we refer to \rfc{6824bis-04}.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/addaddr2}
\caption{ADD\_ADDR2 option}
\label{fig:addaddr2}
\end{figure}

Such format would require the attacker to know the key in order to forge a valid ADD\_ADDR2 message, but such key is not exposed as in the case of the previous solution. Albeit, if the attacker is able to eavesdrop the keys during connection initiation it would be possible to exploit the same vulnerability even with the new address format. More experiments about this case are reported in section \ref{exp}. Possible mitigations for such threat are explained in section \ref{keyseav}.

The keys' eavesdrop threat is a partial-time on-path eavesdrop, a category that is considered less critical in terms of security concerns. Such keys' eavesdrop procedure in MPTCP has an almost identical counterpart in SCTP, when the SCTP-AUTH extension is used without pre-shared keys [\rfc{5061}]. In these regards the same security levels of SCTP would be reached in MPTCP by upgrading ADD\_ADDR to ADD\_ADDR2. Since SCTP is Standard Track, ADD\_ADDR2 is indeed considered a sufficient modification of the MPTCP first design to reach the security levels required for the transition to Standard Track.

\section{Implementing ADD\_ADDR2}
The current MPTCP patch added to the TCP stack in the Linux kernel currently counts around 12000 lines of code [\href{http://multipath-tcp.org/mptcp_stats/index.html}{href}]. It is considered the reference implementation for MPTCP and it closely follows RFC documentation. Moreover, a lot of effort has been put into the implementation design in order to make the new protocol acceptable for upstreaming to the official Linux Kernel. For such purpose, it is of paramount importance to keep the added complexity into the TCP stack as low as possible, in order not to jeopardize performance and stability of regular TCP. Nevertheless, high performance is expected for MPTCP. The main architectural concepts related to the control plane of the protocol are now explained, before introducing the modifications related to the new ADD\_ADDR2 format as defined in \rfc{6824bis-04}. 

\subsection{MPTCP in Linux}
With MPTCP in the Linux Kernel, three main layers are defined in the networking stack to guarantee multipath management and retro-compatibility with regular TCP [\href{http://inl.info.ucl.ac.be/publications/multipath-tcp-theory-practice}{href}]. The first element is the \textit{master subsocket}, which provides the interface used by the applications to communicate with the TCP stack. The structure of the master subsocket follows the regular TCP standards, in order to maintain retro-compatibility towards the application layer: in fact this is the only element used by the kernel in case of regular TCP connectivity. The second element is called \textit{multi-path control block (mpcb)} and it is the main brain of MPTCP, handling MPTCP-specific functionalities: the multi-path control block runs the algorithms that determine when to start or stop subflows, which subflow to chose in order to send a particular piece of data over the network and how to reconstruct the original data from the scattered segments coming from different subflows at the receiver. All the reordering algorithms in the multi-path control block work at the data-level, while the reordering of the data at the single subflows is handled by the underlying regular TCP. The final element of the MPTCP architecture is the set of \textit{slave subsockets}, the actual endpoints for the multiple MPTCP subflows. Such elements are not visible by the application, but they are handled by the multi-path control block. The master subsocket and the slave subsockets form the pool of subflows used in MPTCP.

% Change "multipath control block" with "meta-socket". mpcb is just a component of the meta-socket
\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/architecture}
\caption{MPTCP Linux architecture}
\label{fig:architecture}
\end{figure}


Analyzing to the actual code implementation related to such architecture, it is mainly composed of several data structures linked by pointers. In order to maintain the design-goal if minimizing the impact over regular TCP, when a TCP structure would need additional elements to handle MPTCP-related functionalities, the common choice is to define a new MPTCP-specific structure to store those elements. In this way, upon regular TCP operations, there is no increase in memory-footprint and all the standard TCP structures are in place. On top of that, having specific structures for MPTCP code makes it easier to read and understand the MPTCP components inserted into the TCP stack. For example, a fundamental structure in TCP is the \textit{tcp\_sock} structure, that is used to store the state of a single TCP connection. In MPTCP, additional information for each TCP subflow is needed (for example the Address ID associated to each subflow). A new \textit{mptcp\_tcp\_sock} struct has been defined and each subflow contains a pointer to such new structure. The \textit{mptcp\_tcp\_sock} is a separate structure referenced inside \textit{tcp\_sock} in case of MPTCP connectivity.
Also the previously mentioned main architectural element that is the multi-path control block is implemented in code using a new structure called \textit{mptcp\_cb} (figure \ref{fig:structs}).

\begin{figure}[!htb]
\centering
\includegraphics[width=0.7\textwidth]{images/structs}
\caption{MPTCP high-level data structures with relative references}
\label{fig:structs}
\end{figure}
%from Improving MPTCP

The allocation policy for all the new MPTCP structures is lazy-allocation, meaning that MPTCP structures are allocated only if it is detected that both hosts support the new protocol. This choice is again related to the main purpose of not affecting regular TCP when MPTCP fails during negotiation. A downside of this approach is related to the fact that the TCP stack operations are often executed in a soft-interrupt context, that does not allow functions to sleep in order to wait for available memory: this means that memory allocations might fail, forcing a fallback to regular TCP.

The connection setup in an MPTCP-compatible environment requires the client to send a first MP\_CAPABLE segment: this means that, even if no data structure is allocated during this first stage, the client has to generate a random key, and the related token is also calculated to check that it is not already used to identify another MPTCP connection. A reference to the originated \textit{tcp\_sock} structure is saved inside an hashtable that used to keep track of the ongoing MPTCP connections. At this point, the \textit{tcp\_sock} is called "meta-socket". If the SYN/ACK answer from the server does not contain a valid MP\_CAPABLE option, the client simply removes the reference to the meta-socket from the hashtable before proceeding with a regular TCP handshake procedure. If the server side is MPTCP-compatible and the MP\_CAPABLE is present in the incoming TCP segment, then the MPTCP structures are allocated: \textit{mptcp\_cb} and \textit{mptcp\_tcp\_sock}.
At the server, the status of the connection is not fully operational until the final ACK from the client as required by the TCP three-way handshake. When the SYN packet with MP\_CAPABLE option is processed, a \textit{request\_sock} data structure is allocated that has some additional space for MPTCP-related information with respect to the same structure used for regular TCP. In case no MP\_CAPABLE option is present in the received ACK packet, the regular TCP version of the \textit{request\_sock} data structure is used, following the same design principles previously explained. The random key and uniqueness of the token are procedures executed at the server in a similar way with respect to the client. If the entire MPTCP initialization proceeds as expected, when the server receives the ACK from the client, the master-socket is ready and linked to the \textit{mptcp\_cb}.

After the connection has been established, multiple subflows can be used with MPTCP and there is a modular path-manager interface to allow flexibility in defining the heuristic adopted to decide which interfaces can be used and in which manner. In creating a new subflow, the client has to add the MP\_JOIN option inside the SYN packet and, differently from the MP\_CAPABLE scenario, the MPTCP-related structures like \textit{mptcp\_tcp\_sock} are created early on. At this point, failure wouldn't cause fallback to regular TCP and there is no need to risk memory allocation failures upon reception of the SYN/ACK from the server. Even if the subflows in MPTCP resemble regular TCP connections, the handshake differs with respect to the MP\_CAPABLE case and it now requires four steps to reach fully operational status. The reason for this is that the third ACK now contains the HMAC value calculated by the client that has to be verified and acknowledged by the server before any data can be transmitted on such subflow. 
Regarding the operational flow in the stack upon reception of a SYN packet, there is no early inspection aimed at determining if an MP\_JOIN option is present: that would causes performance degradation in case of regular TCP SYN packets. Instead, the packet is processed with regular TCP stack until, in case of matching with a listening socket, the function \textit{tcp\_v4\_conn\_request()} is called: here the TCP options are scanned, and if MP\_JOIN is present then redirection to MPTCP happens and the lookup in the hashtable is performed to determine which MPTCP connection the new SYN packet is addressing to. If there is no matching socket found for the incoming packet, MPTCP still checks if the SYN message contains the MP\_JOIN option via the \textit{mptcp\_lookup\_join()}. At this point, the server creates a request socket that is saved into the hashtable so that it can be retrieved when the client answers with the ACK message during the last stage of the subflow handshake.

The previous paragraphs presented an overview of the most important data structures and functions used in MPTCP to handle connection establishment and subflow management. The following sections contain an in-depth analysis of the ADD\_ADDR functionality implemented in the Linux kernel and how this was modified to develop the new format ADD\_ADDR2.

\subsection{Truncated HMAC in ADD\_ADDR}
\label{hmacinaddaddr}
The part of code in the Linux kernel defining the format of every MPTCP options is contained in the following header file: \textit{include/net/mptcp.h}. For each MPTCP option there is a corresponding data structure in this header file that contains all the fields for the option in the right order, format and alignment. The ADD\_ADDR option is defined in the \textit{mp\_add\_addr} struct. A first step towards achieving a full implementation of ADD\_ADDR2 is indeed to add the truncated HMAC field into the ADD\_ADDR message and place it after the optional port, both in case of IPv4 and IPv6 (listing \ref{mpaddaddr}, lines 18 and 23).

\begin{lstlisting}[language=c, caption=\textit{mp\_add\_addr struct in the kernel}, label=mpaddaddr]
struct mp_add_addr {
	__u8	kind;
	__u8	len;
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u8	ipver:4,
		sub:4;
#elif defined(__BIG_ENDIAN_BITFIELD)
	__u8	sub:4,
		ipver:4;
#else
#error	"Adjust your <asm/byteorder.h> defines"
#endif
	__u8	addr_id;
	union {
		struct {
			struct in_addr	addr;
			__be16		port;
			__u8		mac[8];
		} v4;
		struct {
			struct in6_addr	addr;
			__be16		port;
			__u8		mac[8];
		} v6;
	} u;
} __attribute__((__packed__));
\end{lstlisting}

The fields in the data structure resemble the content of ADD\_ADDR as exposed from a high level prospective in section \ref{mptcpdesign}. 
A \textit{union} is used to define two alternatives for the option's definition, since the advertised IP address can be a longer IPv6 address or a shorter IPv4 address. 
The HMAC value that is computed using the SHA-1 algorithm is of 160 bits, but only its rightmost 64 bits are parsed into the final packet, hence the usage of an array of eight elements of kind \_\_u8.  
Particular attention is used to correctly pack the structure, in order to avoid additional padding that could be added by the compiler to align the inner fields for performance purposes. Such padding is unwanted in the final packet sent on wire. The \textit{port} field is optional, meaning that additional care has to be taken when parsing the struct in order to build the packet, as it is explained later in this section.

When the transmission of an ADD\_ADDR2 is triggered, there is a specific function called \textit{full\_mesh\_addr\_signal()} (in \textit{net/mptcp/mptcp\_fullmesh.c}) that is called to prepare all the fields that will be later on parsed into the outgoing packet; at this point, the fields are saved in a \textit{tcp\_out\_options} structure, defined in \textit{include/linux/tcp.h}. A new \textit{\_\_u64 trunc\_mac} entry has been added to such structure in order to store the new truncated HMAC used in ADD\_ADDR2. 
In listing \ref{fullmesh} is reported the added code (inside \textit{net/mptcp/mptcp\_fullmesh.c}) that is used to calculate the HMAC value as previously described. Note that all the code reported so far addresses the IPv4 advertisement, but IPv6 support is provided throughout the entire set of produced patches.

It is now important to mention that the ADD\_ADDR2 has been designed as a major update for MPTCP, thus being part of the next version bump (MPTCP version 1). Retro-compatibility with version 0 and ADD\_ADDR has to be guaranteed, meaning that the truncated HMAC is added into the ADD\_ADDR message only if version 1 or higher has been established by both hosts during the initial handshake. More about the newly introduced version control is reported in the next section (section \ref{retrocomp}). It is possible to notice the "if" statement checking that the MPTCP version in use is indeed 1 or greater. The actual hashing function adopted is \textit{mptcp\_hmac\_sha1}; such function, that was already present in the first phases of the MPTCP implementation, has been also modified to properly work with ADD\_ADDR2 (more details about this updated function are reported in section \ref{newhash}). 

\begin{lstlisting}[language=c, caption=\textit{New ADD\_ADDR HMAC calculation (outgoing packet, IPv4)}, label=fullmesh]
...
if (mpcb->mptcp_ver >= MPTCP_VERSION_1) {
	u8 mptcp_hash_mac[20];
	u8 no_key[8];

	*(u64 *)no_key = 0;
	mptcp_hmac_sha1((u8 *)&mpcb->mptcp_loc_key,
		(u8 *)no_key,
		(u32 *)mptcp_hash_mac, 2,
		1, (u8 *)&mptcp_local->locaddr4[ind].loc4_id,
		4, (u8 *)&opts->add_addr4.addr.s_addr);
	opts->add_addr4.trunc_mac = *(u64 *)mptcp_hash_mac;
}
...
\end{lstlisting}

The call to HMAC calculation function \textit{mptcp\_hmac\_sha1()} is now examined keeping as reference listing \ref{fullmesh}. Regarding the key used for the HMAC calculation, that is defined as the concatenation of the first two arguments of the hashing function. It corresponds to the key of the sender as defined during the MP\_CAPABLE exchange (\textit{mpcb->mptcp\_loc\_key}), followed by 8 bytes initialized to 0 (the \textit{no\_key} field). Even if the 8 trailing bytes are not compliant with the specifications in \rfc{6824bis-04}, these are maintained in order not to change the way the hashing function currently manages the keys for the HMAC computation: \textit{mptcp\_hmac\_sha1} accepts exactly two messages of 8 bytes each and concatenates them to form the final hashing key. This incorrect implementation is temporarily acceptable since the protocol specifications regarding this aspect change in the more recent drafts developed after \rfc{6824bis-04}, as reported in section \ref{otherc}.
For what regards the message of the HMAC calculation, that is composed of the Address ID (line 9) and the advertised address (line 10). Note that listing \ref{fullmesh} does not include the code for handling the port value in the HMAC. Indeed, port advertisement is not yet part of the current MPTCP implementation in the Linux Kernel. More details about this can be found later in section \ref{portad}. 
The HMAC calculation produces 160 bits that are saved in the placeholder called \textit{mptcp\_hash\_mac} (line 2), whose pointer is later saved into the new field in \textit{tcp\_out\_options}, referenced by the pointer \textit{opts} (line 11). The same pointer is used later on, in the function \textit{mptcp\_options\_write()} (file \textit{net/mptcp/mptcp\_output.c}), in order to retrieve the saved values and construct the \textit{mp\_add\_addr} data structure (listing \ref{mpoutput}).

\begin{lstlisting}[language=c, caption=\textit{Building ADD\_ADDR2 output message}, label=mpoutput]
...
mpadd->kind = TCPOPT_MPTCP;
if (opts->add_addr_v4) {
	mpadd->sub = MPTCP_SUB_ADD_ADDR;
	mpadd->ipver = 4;
	mpadd->addr_id = opts->addresses.addr_id;
	mpadd->u.v4.addr = opts->add_addr4.addr;
	if (mpcb->mptcp_ver < MPTCP_VERSION_1) {
		mpadd->len = MPTCP_SUB_LEN_ADD_ADDR4;
		ptr += MPTCP_SUB_LEN_ADD_ADDR4_ALIGN >> 2;
	} else {
		memcpy((char *)mpadd->u.v4.mac - 2,
	           (char *)&opts->add_addr4.trunc_mac, 8);
		mpadd->len = MPTCP_SUB_LEN_ADD_ADDR4_VER1;
		ptr += MPTCP_SUB_LEN_ADD_ADDR4_ALIGN_VER1 >> 2;
	}
}
...
\end{lstlisting}

The MPTCP version in use is again checked to determine if to process the HMAC field in \textit{opts} or not. If the version is 1 or greater, then a \textit{memcpy} of the first 8 bytes of the HMAC value is performed to the location \textit{(char *)mpadd->u.v4.mac - 2}; the "-2" is used to start the copying right after the advertised address (IPv4 in this case), thus skipping the optional port field. It is important to mention that the actual implementation of MPTCP for the Linux Kernel lacks the feature about port advertisement: more precisely, a port is never added to the ADD\_ADDR option, but the code to handle a possible port value upon ADD\_ADDR reception is in place and fully operational. Further considerations on port advertisement capabilities can be found in section \ref{portad}. The new ADD\_ADDR2 has different lengths with respect to the previous version, since the 8 bytes truncated HMAC is added. New length values are defined, by adding "\_VER1" to the name of the previous definitions: \textit{MPTCP\_SUB\_LEN\_ADD\_ADDR4\_VER1} is 16 (8 in ADD\_ADDR), and \textit{MPTCP\_SUB\_LEN\_ADD\_ADDR6\_VER1} is 28 (20 in ADD\_ADDR). 

When the ADD\_ADDR(2) message is received, the length of the received option is checked and it has to comply with the expected values, according to the type of message (ADD\_ADDR or ADD\_ADDR2). This check is called in the function \textit{mptcp\_parse\_options()} (listing \ref{badsize}).

\begin{lstlisting}[language=c, caption=\textit{Check ADD\_ADDR size at the receiver, inside \textit{mptcp\_parse\_option()}}, label=badsize]
...
if (!tp)
	break;

if (!is_valid_addropt_opsize(tp->mpcb->mptcp_ver,
			     mpadd, opsize)) {
	mptcp_debug("%s: mp_add_addr: bad option size %d\n",
     		    __func__, opsize);
 	break;
...
\end{lstlisting}

An issue encountered at this point of development was that the function just mentioned was initially called with no reference to the multi-path control block structure where the version of the current MPTCP session is stored. The MPTCP version is no more passed along in the options following the MP\_CAPABLE exchange, meaning that the value can't be retrieved directly from parsing the ADD\_ADDR option. A first workaround was to add the version value in the structure containing the received options, named \textit{mptcp\_options\_received}, before passing the structure to the actual parsing function. Anyway, this might be confusing to the developers, since it looks like the MPTCP version value has been indeed received within the options inside the TCP segment, while it was in reality saved at connection initialization. The final approach to solve the problem involved slightly more complex changes for the set of function calls related to the parsing of TCP/MPTCP options: as it can be seen in the first line of listing \ref{badsize}, the \textit{tcp\_sock} (\textit{tp}) structure containing the \textit{mpcb} data for the connection is available inside \textit{mptcp\_parse\_option()}, and it can be passed along to the opsize checking function \textit{is\_valid\_addropt\_opsize()}. This required to modify the \textit{tcp\_parse\_options()} function in the TCP stack to pass along the pointer to the \textit{tcp\_sock}, so that it can be retrieved further down within the function calls chain (listing \ref{tcpparse}, last line). Note that the \textit{tp} pointer can be null in certain cases (for example if \textit{tcp\_parse\_options()} is called from \textit{tcp\_timewait\_state\_process()} while the MPTCP is shutting down), meaning that a null check is performed before calling the validation function: if that is the case, it is impossible to retrieve the MPTCP version and the ADD\_ADDR(2) is simply ignored.

\begin{lstlisting}[language=c, caption=\textit{New definition for \textit{tcp\_parse\_options}}, label=tcpparse]
void tcp_parse_options(const struct sk_buff *skb,
 		       struct tcp_options_received *opt_rx,
 		       struct mptcp_options_received *mopt_rx,
		       int estab, struct tcp_fastopen_cookie *foc);
		       int estab, struct tcp_fastopen_cookie *foc,
		       struct tcp_sock *tp);
\end{lstlisting}

Regarding the \textit{is\_valid\_addropt\_opsize()} function, it has been developed as a separate inline function called inside the "if" statement" for better readability, since the length's check with the additional ADD\_ADDR2 case involves now four possible configurations; the entire function content can be found in the appendix [add appendix reference where the patch is].

Eventually, the function \textit{mptcp\_handle\_add\_addr()} takes care of verifying the HMAC and triggering the procedures used to add the advertised address, if appropriate. The IPv4 version of the HMAC verification code at the receiver is shown in listing \ref{addaddrinput}, where the HMAC calculated locally is compared with the one received in the ADD\_ADDR2 message with the \textit{memcmp()} in line 8: the "return" in line 10 does indeed prevents the information from ADD\_ADDR2 to be further processed, if \textit{memcmp()} fails. 

\begin{lstlisting}[language=c, caption=\textit{New ADD\_ADDR HMAC calculation (incoming packet)}, label=addaddrinput]
...
mptcp_hmac_sha1((u8 *)&mpcb->mptcp_rem_key,
				(u8 *)no_key,
				(u32 *)hash_mac_check, msg_parts,
				1, (u8 *)&mpadd->addr_id,
				4, (u8 *)&mpadd->u.v4.addr.s_addr,
				2, (u8 *)&mpadd->u.v4.port);
if (memcmp(hash_mac_check, recv_hmac, 8) != 0)
	/* ADD_ADDR2 discarded */
	return;
...
\end{lstlisting}

%Apparently there was a bug there! You can mention it and the related patch. https://listes-2.sipr.ucl.ac.be/sympa/arc/mptcp-dev/2016-02/msg00007.html

\subsection{MPTCP version control}
\label{retrocomp}
ADD\_ADDR2 is substantial modification of an important design aspect of the MPTCP protocol. ADD\_ADDR2 is indeed non interoperable with the current stable implementation of MPTCP version 0, since the augmented length of the option would cause the older network stack to discard the option right away.
ADD\_ADDR2 is considered part of the new MPTCP protocol version number 1, whose implementation has to guarantee retro-compatibility. For this purpose, a version control mechanism has to be in place so that hosts can agree on the version to use upon initial handshake and successively operate according to such decision. Since ADD\_ADDR2 is the first step towards the implementation of the new features for MPTCP version 1, no version control mechanism was provided at the beginning of the development phase for ADD\_ADDR2: version 0 was just an hardcoded value parsed into each MP\_CAPABLE option (option's format is shown in figure \ref{fig:opt_capable}) with no logic attached.


MPTCP version 1 is currently a moving target, so the version bump is not included inside the patch for ADD\_ADDR2 that is just a part of the future changes introduced with the new version (more about this in the section \ref{future}). For this reason, it has been decided to give the system administrator the possibility of dynamically set the MPTCP version via a sysctl call, like the following:

\begin{verbatim}
        sysctl -w net.mptcp.mptcp_version=1
\end{verbatim}

It is possible to identify three main phases in the version agreement procedure, defined in \rfc{6824bis-04}:

\begin{enumerate}
  \item The client insert the highest available MPTCP version number it supports into the MP\_CAPABLE option;
  \item When the server gets the first MPTCP packet, it checks the version advertised by the client and answer with the highest version it supports that is less or equal to the client's version;
  \item As a last step, the client receives the answer from the server, and it checks that it is indeed a valid version (i.e. it is no greater than the one the client advertised in the first place); at this point, the client can backtrack to regular TCP if it does not wish to use the requested version.
\end{enumerate}

In developing MPTCP version control mechanism, a problem was related to the fact that the user can change the version in use at any time via a sysctl command, meaning that it is possible to change the version in the middle of an MPTCP connection. It is not desirable to change such configuration during the MP\_CAPABLE exchange: it is possible that the first MP\_CAPABLE is retransmitted to the passive opener (following standard TCP retransmission procedures), and the version number inside retransmitted packets must not change from the one used in the very first transmission. For this reason, the configured sysctl value is read and initialized for the MPTCP connection at an early stage, namely when \textit{mptcp\_enable\_sock()} in \textit{net/mptcp/mptcp\_ctrl.c} is called; there, the value is saved into the newly introduced field \textit{mptcp\_ver} inside the \textit{tcp\_sock} structure (listing \ref{verphase0}, line 5).

\begin{lstlisting}[language=c, caption=\textit{MPTCP version agreement, initializing sysctl value}, label=verphase0]
...
void mptcp_enable_sock(struct sock *sk)
{
	if (!sock_flag(sk, SOCK_MPTCP)) {
		sock_set_flag(sk, SOCK_MPTCP);
		tcp_sk(sk)->mptcp_ver = sysctl_mptcp_version;
	...
\end{lstlisting}

Even if the sysctl value is changed by the user after the \textit{mptcp\_enable\_sock()} has been called, the value in \textit{tcp\_sock} for a specific connection is not affected, and that is indeed the value used to create and send the SYN+MP\_CAPABLE option (even in case of retransmissions). 


The same initialization procedure is executed when the MP\_CAPABLE packet is received at the server side, meaning that the code for version agreement at the server also retrieves the local MPTCP version via \textit{tp->mptcp\_ver}, where \textit{tp} is the pointer to the \textit{tcp\_struct} for the connection (listing \ref{verphase2}). The function \textit{mptcp\_reqsk\_new\_mptcp()} in \textit{net/mptcp/mptcp\_ctrl.c} is called when the SYN+MP\_CAPABLE is received and the code in listing \ref{verphase2} is executed to set the highest version available that is not greater than the one advertised by the client. The \textit{mopt} pointer points to the structure containing the received MPTCP options from the client, while \textit{mtreq} is a pointer to the \textit{mptcp\_request\_sock} structure, where the final version chosen by the server is saved for now.

\begin{lstlisting}[language=c, caption=\textit{MPTCP version agreement, phase 2}, label=verphase2]
	if (mopt->mptcp_ver >= tp->mptcp_ver)
		mtreq->mptcp_ver = tp->mptcp_ver;
	else
		mtreq->mptcp_ver = mopt->mptcp_ver;
\end{lstlisting}

The last step of the version agreement involves the final check performed by the client on the version value sent back by the server: it has to be equal or less then the one originally advertised in the first MP\_CAPABLE message. Such check is added to the function \textit{mptcp\_rcv\_synsent\_state\_process()} inside \textit{net/mptcp/mptcp\_input.c} (listing \ref{verphase3}): \textit{tcp\_sk(sk)} is used to obtain the pointer to the \textit{tcp\_sock} structure, where \textit{mptcp\_ver} is retrieved and compared to the server's MPTCP version residing in \textit{mopt->mptcp\_ver}. If the comparison fails, the \textit{fallback} label is hit to trigger the fallback procedure to regular TCP.

\begin{lstlisting}[language=c, caption=\textit{MPTCP version agreement, phase 3}, label=verphase3]
	if (mopt->mptcp_ver > tcp_sk(sk)->mptcp_ver)
		/* TODO Consider adding new MPTCP_INC_STATS entry */
		goto fallback;
\end{lstlisting}

After these messages have been exchanged, if a proper version has been agreed, both hosts will eventually call \textit{mptcp\_create\_master\_sk()} and in turns \textit{mptcp\_alloc\_mpcb()} with the information about the version, so that it is also saved in the MPTCP control block \textit{mptcp\_cb} for the session. From the multi-path control block, the MPTCP version in use can be retrieved to process the ADD\_ADDR option accordingly as explained in previous section \ref{hmacinaddaddr}.

\subsection{The MPTCP hashing function}
\label{newhash}
The current implementation of MPTCP in the Linux kernel adopts a specific function for all the HMAC-SHA1 calculations required by the protocol: it is named \textit{mptcp\_hmac\_sha1()} and it is placed inside \textit{net/mptcp/mptcp\_ctrl.c}. Before the introduction of ADD\_ADDR2, only the MP\_JOIN option required such functionality, with a fixed scheme regarding the type and length of the \textit{key} and \textit{message} used as input for the HMAC algorithm: the key is always the concatenation of the two 64-bit MPTCP keys exchanged via the MP\_CAPABLE option, while the message is always the combination of two random nonces of 32 bits each. For this reason, the function has been designed to accept such input values with no flexibility on the length and number of the byte strings passed along for the HMAC computation. The old prototype for \textit{mptcp\_hmac\_sha1()} is shown in listing \ref{oldhmac}.

\begin{lstlisting}[language=c, caption=\textit{Prototype for the old \textit{mptcp\_hmac\_sha1() function}}, label=oldhmac]
void mptcp_hmac_sha1(u8 *key_1, u8 *key_2, u8 *rand_1, u8 *rand_2, 
                     u32 *hash_out);
\end{lstlisting}
 
The old implementation of the function concatenates the first 8 bytes pointed by \textit{key\_1} and \textit{key\_2} to get the 16 bytes key, and it concatenates the first 4 bytes of \textit{rand\_1} and \textit{rand\_2} to originate the 8 bytes message. The \textit{hash\_out} pointers references to the placeholder for the final result of the calculation (which is 20 bytes long).


With ADD\_ADDR2 the requirements for the HMAC calculation changed. The hashing key follows the same configuration of the MP\_JOIN case, while the message is now the concatenation of some of the fields in the ADD\_ADDR2 option, namely the single byte Address ID, the advertised IP address that can be a 4 bytes IPv4 address or a IPv6 16 bytes address and, if present, the 2 bytes port value. Instead of implementing a separate hashing function for dealing with this case,  it was decided to extend the current one in order to accept an arbitrary number of messages of arbitrary length (checking that the total length doesn't go over a certain limit). For what concerns the HMAC key, that part is expected not to change for future usage in MPTCP since it is most likely based on the two MPTCP keys exchanged during the initial handshake. For the message part, the new function uses that C functionality for variable argument lists based on va\_list. Only the first part of the new hashing function's implementation is changed, since it is the one that handles the input key and message passed as argument. This new first part is shown in listing \ref{newhmac}.

\begin{lstlisting}[language=c, caption=\textit{Implementation for the new \textit{mptcp\_hmac\_sha1() function (first part)}}, label=newhmac]
void mptcp_hmac_sha1(u8 *key_1, u8 *key_2, 
                     u32 *hash_out, int arg_num, ...)
{
    u32 workspace[SHA_WORKSPACE_WORDS];
	u8 input[128]; /* 2 512-bit blocks */
	int i;
	int index;
	int length;
	u8 *msg;
	va_list list;

	memset(workspace, 0, sizeof(workspace));

	/* Generate key xored with ipad */
	memset(input, 0x36, 64);
	for (i = 0; i < 8; i++)
		input[i] ^= key_1[i];
	for (i = 0; i < 8; i++)
		input[i + 8] ^= key_2[i];

	va_start(list, arg_num);
	index = 64;
	for (i = 0; i < arg_num; i++) {
		length = va_arg(list, int);
		msg = va_arg(list, u8 *);
		BUG_ON(index + length > 125); /* Message is too long */
		memcpy(&input[index], msg, length);
		index += length;
	}
	va_end(list);

	input[index] = 0x80; /* Padding: First bit after message = 1 */
	memset(&input[index + 1], 0, (126 - index));

	/* Padding: Length of the message = 512 + message length (bits) */
	input[126] = 0x02;
	input[127] = ((index - 64) * 8); /* Message length (bits) */
	...
}
\end{lstlisting}

The \textit{input} array is prepared for the subsequent HMAC-SHA1 operations (not reported here). From line 13 to line 16 it is possible to verify that the 16 bytes' key is properly xored with the first 16 bytes of the array as required for the proper HMAC calculation. From line 18 to line 27 the "for" loop scans the function arguments by retrieving two subsequent argument at a time: the first is an integer representing the length of the currently processed message, while the second is the pointer to the actual message. After checking that the total length of the concatenated message is not too long, the message is properly parsed into the \textit{input} array, before advancing the index accordingly and starting a new "for" loop. The last part of the code snippet shows some padding additions required by the hashing function's implementation at later stages not shown here. 
To sum up, the new API requires to pass along the following set of information (in this order): pointer to the first 8 bytes of the HMAC key, pointer to the following 8 bytes of the key, pointer to the 20-byte placeholder where to save the final result of the HMAC calculation, the number of HMAC message's parts that have to be processed and, finally, the pointers to the various components composing the final HMAC input message; each of the pointers to a message components has to be preceded by an integer determining the byte-length of the component itself.

A few considerations should be made about the total length of the final HMAC input message. From the code on listing \ref{newhmac} it can be seen that the message shouldn't be longer than 62 bytes: this number comes from the limit value 125 (included) in line 26 minus the initial \textit{index} value of 64 in line 22. The limit value 125 has been chosen so that the first bit after the message is set to one (actually, the entire byte after the last byte of the message is set to 0x80), keeping the very last two fields in the \textit{input} array reserved to the length value composed as the sum of 512 (bits composing the first half of the input array) plus the number of bits composing the actual HMAC message. Such configuration is required by the following hashing implementation to work. 
62 bytes for the HMAC message is a very conservative value for the MPTCP case. As of now, the longest possible message to be processed for ADD\_ADDR2 would be of length 19 bytes: 1 byte for the Address ID, 16 bytes for the IPv6 address and two more bytes for the port value.
Moreover, it has been decided to introduce a BUG\_ON macro as a check for the message length, so that the whole system would crash reporting the needed trace information in case the message is too long. Even if crashing the whole Kernel in case of a failure in MPTCP might seem a too drastic approach, the reasoning behind it is that such input messages does not depends on any external input: in other words, the number and length of the messages passed to the hashing function are hardcoded inside the Kernel code and they are within the limits, meaning that such BUG\_ON procedure will never be called during normal execution of the current implementation. Only new uses of the hashing function introduced by developers during development phase could introduce a wrong usage of the new API: during the development phase it is reasonable to fail loudly if something goes wrong, providing all the means for the developers to notice and address the problem.

Extending the hashing function used in MPTCP as just described has been the final solution adopted to implement ADD\_ADDR2. Nevertheless, another important investigation has been performed about an alternative way to achieve HMAC calculation within MPTCP. Such alternative takes into consideration the usage of the Crypto API framework, that is already available in the Linux kernel. Code re-usability is a fundamental aspect of Kernel development, and the Crypto module offers all the most popular block ciphers and hash functions computations, including the HMAC-SHA1. Such API has been introduced in the Linux kernel version 2.5.45 [\href{http://lwn.net/Articles/13587/}{href}], and it is now considered very stable and optimized for fast performances. 
A patch to test the behavior of Crypto APIs in MPTCP has been developed [reference to the appendix] and tested. The \textit{mptcp\_hmac\_sha1()} API would be still extended to achieve better flexibility in managing the input messages, but it would end up being a simple wrapper calling the Crypto API functions, as shown in listing \ref{crypto}.

\begin{lstlisting}[language=c, caption=\textit{\textit{mptcp\_hmac\_sha1() using Linux kernel Crypto API}}, label=crypto]
void mptcp_hmac_sha1(u8 *key_1, u8 *key_2, u8 *hash_out, int arg_num, ...)
{
	struct mptcp_hmacsha1_pool *sp;
	struct scatterlist sg;
	u8 *key;
	int i;
	int length;
	u8 *msg;
	va_list list;

	sp = mptcp_get_hmacsha1_pool();
	if (!sp)
		goto clear_hmac_noput;
	sp->hmacsha1_desc.flags = 0;
	key = sp->key_placeholder;

	memcpy(&key[0], key_1, 8);
	memcpy(&key[8], key_2, 8);

	if (crypto_hash_setkey(sp->hmacsha1_desc.tfm, (u8 *)key, 16))
		goto clear_hmac;
	if (crypto_hash_init(&sp->hmacsha1_desc))
		goto clear_hmac;

	va_start(list, arg_num);
	for (i = 0; i < (arg_num); i++) {
		length = va_arg(list, int);
		msg = va_arg(list, u8 *);
		sg_init_one(&sg, msg, length);
		if (crypto_hash_update(&sp->hmacsha1_desc, &sg, length))
			goto clear_hmac;
	}
	va_end(list);

	if (crypto_hash_final(&sp->hmacsha1_desc, hash_out))
		goto clear_hmac;
	mptcp_put_hmacsha1_pool();
	return;

clear_hmac:
	mptcp_put_hmacsha1_pool();
clear_hmac_noput:
	memset((u8 *)hash_out, 0, 20);
	return;
}
\end{lstlisting}

Some of the Crypto functions' operations are straightforward: from a high level prospective, \textit{crypto\_hash\_setkey()} sets the HMAC-SHA1 key, \textit{crypto\_hash\_update()} automatically adds component to the HMAC-SHA1 message every time it is called and finally the \textit{crypto\_hash\_final()} computes the HMAC-SHA1 value.
However, there is an important initialization part that is required for proper functioning of such Crypto functions, that is performed at the very beginning of the connection establishment, i.e. in the \textit{tcp\_init\_sock()} function inside \textit{net/ipv4/tcp.c}. The reason why the initialization part is performed at an early stage during connection establishment instead of just before the need to compute the HMAC value is that the Crypto library is not designed to work in an atomic context, since it involves memory allocations with the option GFP\_KERNEL: such option allows the allocation function to sleep and wait for available memory if that is not available immediately. However, sleeping is not allowed in atomic-context execution, which is the context in use when processing the MPTCP options. The function \textit{tcp\_init\_sock()} is not called in an atomic context, and it is a viable option where to insert the allocation function needed for the Crypto library. The Crypto function to allocate the required memory and algorithms is called \textit{crypto\_alloc\_hash()}, and it takes as first argument the kind of hashing algorithm to use, which in MPTCP case is: \textit{"hmac(sha1)"} (listing \ref{cryptoalloc}).

\begin{lstlisting}[language=c, caption=\textit{\textit{Initializing the Crypto API framework}}, label=cryptoalloc]
	struct crypto_hash *hash;

	hash = crypto_alloc_hash("hmac(sha1)", 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR_OR_NULL(hash))
		return;
	per_cpu(mptcp_hmacsha1_pool, cpu).hmacsha1_desc.tfm = hash;
\end{lstlisting}

The \textit{crypto\_hash} structure is the object needed by the subsequent Crypto functions present in \textit{mptcp\_hmac\_sha1()}; it is saved in the "per\_cpu" structure called \textit{mptcp\_hmacsha1\_pool} and it is retrieved from the same structure as shown in line 11 of listing \ref{crypto}. The "per\_cpu" usage allows for better performances in a multi-core environment; even if this is out of the scope of this paper, the full implementation can be found in the appendix [add appendix].

This preallocation solution described, that calls \textit{crypto\_alloc\_hash()} early on in the MPTCP operational flow, is not enough to guarantee correct functioning of the Crypto framework when the call to \textit{crypto\_hash\_setkey()} is also needed (listing \ref{crypto}, line 19). In fact, by inspecting the function to set the key value, it is possible to find cases in which memory allocations of kind GFP\_KERNEL are executed. It cannot be guaranteed with that sleeping will never be triggered in an atomic context thus causing Kernel crash. To cope with this problem, further investigation has been performed to verify what could cause a GFP\_KERNEL allocation in \textit{crypto\_hash\_setkey()}. If the input key is not aligned then another function (\href{http://lxr.free-electrons.com/source/crypto/shash.c#L61}{href}) is called for alignment purposes and the alignment process itself can cause sleeping (\href{http://lxr.free-electrons.com/source/crypto/shash.c#L43}{href}). In order to solve also this problem, an additional preallocation as been added right after the  \textit{crypto\_alloc\_hash()}, and shown in listing \ref{keyprealloc}: here, the alignment procedure is performed on the placeholder for the key that might be set later during the MPTCP connection. This preallocation is possible because the length of the key in MPTCP is fixed (\textit{keylen} in line 3 always has a fixed value of 16).
Also the pointer to this aligned placeholder is added to the \textit{mptcp\_hmacsha1\_pool} struct and retrieved in \textit{mptcp\_hmac\_sha1()} as shown in \ref{crypto}, line 15. 

\begin{lstlisting}[language=c, caption=\textit{\textit{Preallocating an aligned placeholder for the HMAC key}}, label=keyprealloc]
...
/* Allocating aligned key_placeholder */
alignmask = crypto_hash_alignmask(hash);
absize = keylen + (alignmask & ~(crypto_tfm_ctx_alignment() - 1));
buffer = kmalloc(absize, GFP_KERNEL);
if (!buffer)
	return;
alignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
per_cpu(mptcp_hmacsha1_pool, cpu).key_placeholder = alignbuffer;
...
\end{lstlisting}

Despite all the precautions adopted in the process, using the Crypto library in the atomic context of the network stack is not a supported out-of-the-box and it is not advisable to deploy such solution. The investigation about the usage of the Crypto API in the MPTCP implementation stopped at this point, but the entire work and related patches have been made available for future references. If the Crypto framework is updated to work in atomic context, then its usage in MPTCP would be the most likely the best option. Another possibility is to study all the possible paths and functions that can be reached by \textit{crypto\_hash\_setkey()} to make sure that all the required memory allocations have been already taken care of before entering the atomic context. For now, the separate function \textit{mptcp\_hmac\_sha1()} made available in MPTCP is considered the best solution.

\subsection{Port advertisement}
\label{portad}
Port advertisement in ADD\_ADDR is possible according to RFC specifications but it is only partially supported by the implementation of MPTCP for the Linux Kernel. In fact, the MPTCP in Linux Kernel is currently able to properly adopt port values advertised in the incoming ADD\_ADDR messages, but there is no code that allows to add the port field in the outgoing messages.
Portions of the code used to process incoming ADD\_ADDR messages is now reported in listing \ref{portreceiver} (IPv4 case is shown).

\begin{lstlisting}[language=c, caption=\textit{Handling port field in ADD\_ADDR2 at the receiver}, label=portreceiver]
...
if (mpadd->ipver == 4) {
    ...
	recv_hmac = (char *)mpadd->u.v4.mac;
	if (mpadd->len == MPTCP_SUB_LEN_ADD_ADDR4_VER1) {
		recv_hmac -= sizeof(mpadd->u.v4.port);
		msg_parts = 2;
	} else if (mpadd->len == MPTCP_SUB_LEN_ADD_ADDR4_VER1 + 2) {
		msg_parts = 3;
	}
	mptcp_hmac_sha1((u8 *)&mpcb->mptcp_rem_key,
	        			(u8 *)no_key,
			      	(u32 *)hash_mac_check, msg_parts,
				    1, (u8 *)&mpadd->addr_id,
				    4, (u8 *)&mpadd->u.v4.addr.s_addr,
				    2, (u8 *)&mpadd->u.v4.port);
	...
	if ((mpcb->mptcp_ver == MPTCP_VERSION_0 &&
	     mpadd->len == MPTCP_SUB_LEN_ADD_ADDR4 + 2) ||
	     (mpcb->mptcp_ver == MPTCP_VERSION_1 &&
	     mpadd->len == MPTCP_SUB_LEN_ADD_ADDR4_VER1 + 2))
		port  = mpadd->u.v4.port;
	...	
}
...
\end{lstlisting}

It is possible to notice that the port field is identified by inspecting the actual length of the ADD\_ADDR message according to the MPTCP version in use. If the length of the option is equal to \textit{MPTCP\_SUB\_LEN\_ADD\_ADDR4\_VER1 + 2}, then the port value is present together with the advertised IPv4 address (similar code is in place for the IPv6 case): in this case, the \textit{msg\_parts} is set to three in order to include the port in the HMAC calculation performed by the call to \textit{mptcp\_hmac\_sha1()}, (whose API is explained in section \ref{newhash}). A similar length check is performed to save the port value found in the ADD\_ADDR(2) option, if present (line 18). 

In the previous section it has been mentioned that the port advertisement is not yet supported at the sender, and that can be checked by inspecting listings \ref{fullmesh} and \ref{mpoutput} for the outgoing packets generation. 
However, in order to properly test all the patches developed during the thesis work, port advertisement support has been partially implemented to test this functionality. If the kernel intends to announce an IP address, the first function taking care of retrieving such provided address and preparing all the fields for ADD\_ADDR is the following: \textit{full\_mesh\_addr\_signal()} (in \textit{net/mptcp/mptcp\_fullmesh.c}). There, the interested fields are saved into the \textit{opts} pointer (\textit{tcp\_out\_options} struct) and later retrieved in \textit{mptcp\_options\_write()} (listing \ref{mpoutput}). In the latter function, a newly introduced flag bit in \textit{opts} called \textit{add\_addr\_port} would be used to determine if a port value has indeed to be written in the outgoing ADD\_ADDR(2) message. The actual "write" function in \textit{mptcp\_options\_write()} with port advertisement support would look like the one in listing \ref{outport} (IPv4 case shown).

\begin{lstlisting}[language=c, caption=\textit{Code to write the outgoing ADD\_ADDR(2) packet, with added support for the port value}, label=outport]
	...
	mpadd->kind = TCPOPT_MPTCP;
	if (opts->add_addr_v4) {
		mpadd->sub = MPTCP_SUB_ADD_ADDR;
		mpadd->ipver = 4;
		mpadd->addr_id = opts->add_addr4.addr_id;
		mpadd->u.v4.addr = opts->add_addr4.addr;
		len_align = MPTCP_SUB_LEN_ADD_ADDR4_ALIGN >> 2;
		if (!opts->add_addr_port) {
			mpadd->len = MPTCP_SUB_LEN_ADD_ADDR4;
			goto no_port_v4;
		}
		mpadd->u.v4.port = opts->add_addr4.port;
		if (mpcb->mptcp_ver < 1) {
			mpadd->len = MPTCP_SUB_LEN_ADD_ADDR4 + 2;
			/* Add padding at the end of option */
			padd_area = (char *)&mpadd->u.v4.port;
			padd_area += sizeof(mpadd->u.v4.port);
			*(padd_area++) = TCPOPT_NOP;
			*(padd_area++) = TCPOPT_NOP;
			/* Adding 4 due to port and two NOP's */
			len_align =
			(MPTCP_SUB_LEN_ADD_ADDR4_ALIGN + 4) >> 2;
			goto next_phase_v4;
		}
		mpadd->len = MPTCP_SUB_LEN_ADD_ADDR4_VER1 + 2;
		memcpy(mpadd->u.v4.mac,
		       (char *)&opts->add_addr4.trunc_mac, 8);
		/* Add padding at the end of option */
		padd_area = (char *)&mpadd->u.v4.mac;
		padd_area += sizeof(mpadd->u.v4.mac);
		*(padd_area++) = TCPOPT_NOP;
		*(padd_area++) = TCPOPT_NOP;
		/* Adding 4 due to port and two NOP's */
		len_align =
		(MPTCP_SUB_LEN_ADD_ADDR4_ALIGN_VER1 + 4) >> 2;
		goto next_phase_v4;
no_port_v4:
		if (mpcb->mptcp_ver < 1)
			goto next_phase_v4;
		mpadd->len = MPTCP_SUB_LEN_ADD_ADDR4_VER1;
		memcpy((char *)mpadd->u.v4.mac - 2,
		       (char *)&opts->add_addr4.trunc_mac, 8);
		len_align = MPTCP_SUB_LEN_ADD_ADDR4_ALIGN_VER1 >> 2;
next_phase_v4:
		ptr += len_align;
	}
	...
\end{lstlisting}

At line 9 it is possible to find the check regarding the presence of a valid port value in \textit{opts->add\_addr4.port}. This code will also add padding in case the port is written into the message, as required in TCP. This solution have been adopted during the development work for the thesis in order to test random, hardcoded ports for both ADD\_ADDR and ADD\_ADDR2. However, the code to handle port writing in the outgoing ADD\_ADDR(2) messages was not eventually merged into the official MPTCP implementation because of the added complexity that is not required at the moment, since no port is ever advertised with the current underlying code handling path management.

\subsection{IPv6 considerations}
So far, all the code and examples have addressed the advertising of an IPv4 address. IPv6 support was eventually added, and from the code prospective it mainly copies the IPv4 counterpart, with proper modifications related to the new length of the IPv6 address, that is 16 bytes long. 

The maximum size allowed for the TCP \textit{Options} field is 40 bytes. The ADD\_ADDR2 option would add up to 30 bytes when and IPv6 address is advertised with the port value (32 bytes, if padding is added). Since it is very unlikely that such a long option would fit if other options are already present in the packet, the \rfc{6824bis-04} states that the ADD\_ADDR2 message should be sent in a duplicate ACK, with no other payload or option. 
For example, in the testing scenario adopted for the thesis work, the Timestamp (12 bytes) and DSS (8 bytes) options were always present in the packet together with ADD\_ADDR(2), meaning that the ADD\_ADDR2 with IPv6 was never added to the packets due to the size limits. Indeed, adding the ADD\_ADDR(2) option in the outgoing packets is treated in the current Linux Kernel implementation as a best effort procedure with no procedure to send the option alone in a duplicate ACK, somehow differently from what it is suggested in the mentioned RFC document.

Eventually, an intermediate approach has been adopted for the new ADD\_ADDR2 format during the development of ADD\_ADDR2: only if an IPv6 is advertised, then all the other MPTCP options in the packet are not added (regular TCP options are not affected). This is done in \textit{mptcp\_established\_options()} (file \textit{ net/mptcp/mptcp\_output.c}), by checking the version of the advertised IP address, processing the ADD\_ADDR2 packet information for the outgoing packet, and then returning in the IPv6 case, so that no other options are processed in the function (listing \ref{ipv6}).

\begin{lstlisting}[language=c, caption=\textit{In IPv6 case, MPTCP options are not added if ADD\_ADDR2 is present}, label=ipv6]
...
if (unlikely(mpcb->addr_signal) && mpcb->pm_ops->addr_signal) {
	mpcb->pm_ops->addr_signal(sk, size, opts, skb);
	if (opts->add_addr_v6)
		/* Skip subsequent options */
		return;
}
...
\end{lstlisting}


\section{Overall contributions}
\label{otherc}

\subsubsection{MPTCP Linux implementation}
The previous sections described the development process for ADD\_ADDR2 and the related aspects regarding MPTCP version control and the extension of the HMAC-SHA1 function used in MPTCP. 
The overall code has been submitted into four different patches:
% Include also reference to the appendix section
\begin{itemize}
  \item mptcp: Add MPTCP version control [\href{https://github.com/multipath-tcp/mptcp/commit/c9b4b66a0e544b3eae5d898206b5a28628b728a7}{href}];
  \item mptcp: Make 'mptcp\_hmac\_sha1' more flexible [\href{https://github.com/multipath-tcp/mptcp/commit/f860de960e19cb557400c08e49288af63c51319f}{href}];
  \item mptcp: Add ADD\_ADDR2 option [\href{https://github.com/multipath-tcp/mptcp/commit/de09a83186666c67c9831057a83ba426f91fbea3}{href}];
  \item mptcp: Add IPv6 support for ADD\_ADDR2 [\href{https://github.com/multipath-tcp/mptcp/commit/8e86cf262108513296ac0952f2ffef717dc12f4b}{href}].
\end{itemize}

The first implementation of ADD\_ADDR2 for MPTCP has been also mentioned in the official MPTCP [\href{http://blog.multipath-tcp.org/blog/html/2016/01/05/mptcpnews.html#}{href}].

\subsubsection{RFC6824}
As a complementary part of the development process for the MPTCP implementation in the Linux Kernel, there was the effort to improve the official documentation counterpart for the protocol. In particular, a somewhat substantial modification have been proposed regarding the key adopted for the HMAC computation in ADD\_ADDR2. In \rfc{6824bis-04} it is indicated to use the MPTCP session key of the sender as the only security material, but there is no valid reason not to adopt the sender's key concatenated with the receiver's key. In fact, when an ADD\_ADDR2 is issued the connection is already established, meaning that both hosts know both keys, and concatenating them for the HMAC hashing key improves security overall (an attacker has to know both keys to forge valid HMAC values). Moreover, from an implementation perspective, maintaining the same key configuration used in MP\_JOIN provides code re-usability for the MPTCP hashing function \textit{mptcp\_hmac\_sha1()}.
These reasonings have been pointed out in the official IETF mailing-list and they have been positively reviewed [\href{https://mailarchive.ietf.org/arch/search/?email_list=multipathtcp&q=RFC6824bis-04+ADD_ADDR2+comments}{href}]: \rfc{6824bis-05}, released in January 2016, modifies the specifications for ADD\_ADDR2 so that both keys are used. For this reason it is acceptable to keep the \textit{no\_key} value in the code as a temporary (incorrect) implementation of \rfc{6824bis-04} standards, since it will be soon replaced with the key of the receiver (as mentioned in section \ref{hmacinaddaddr}). 
In the same email sent to the IETF mailing-list has been pointed out that the port usage for the HMAC message computation is not very clear in \rfc{6824bis-04}. In fact, when no port is advertised it should be specified how to handle the HMAC generation, if to avoid the port value at all or to use it anyway with a value of 0. This point has indeed been clarified in the latest RFC draft, \rfc{6824bis-05}, opting for the second solution. The RFC section on ADD\_ADDR2 including the new specifications is reported here:

\begin{verbatim}
   In the same way as for MP_JOIN, the key for the HMAC
   algorithm, in the case of the message transmitted by Host A, will be
   Key-A followed by Key-B, and in the case of Host B, Key-B followed by
   Key-A.  These are the keys that were exchanged in the original
   MP_CAPABLE handshake.  The message for the HMAC is the Address ID, IP
   Address, and Port which precede the HMAC in the ADD_ADDR option.  If
   the port is not present in the ADD_ADDR option, the HMAC message will
   nevertheless include two octets of value zero.
\end{verbatim}

\subsubsection{RFC7430}
A minor RFC Errata has been sent regarding the document 'Analysis of Residuals Threats and Possible Fixes for Multipath TCP (MPTCP)' (\rfc{7430}), since a wrong classification has been assigned to the SYN/JOIN attack in section 6. Such attack is not a \textit{partial-time on-path eavesdropper} but the type is \textit{partial-time on-path active attacker} [\href{http://www.rfc-editor.org/errata_search.php?rfc=7430&eid=4565}{href}].

\subsubsection{Nimai Scapy tool}
The Scapy tool with MPTCP support (found at \textit{https://github.com/nimai/mptcp-scapy}) that has been used to perform all the attacking tests have been slightly modified to make it compatible with the new format for ADD\_ADDR2. In this way it was possible to test the new packet format and verify the correct functioning of the implemented patches (as shown in the following section \ref{exp}, 'Experimental evaluation'). It was enough to add the new HMAC field in the class definition for the ADD\_ADDR messages, found in \textit{scapy/layers/mptcp.py}, as shown in listing \ref{scapy2} at line 11 (option with no port field) and line 23 (option with the port field).

\begin{lstlisting}[language=Python, caption=\textit{Scapy ADD\_ADDR2 class definition}, label=scapy2]
...
class MPTCP_AddAddr(MPOption):
    name = "Multipath TCP Add Address"
    subtype = 3
    subsubtype = 8<<4+3
    fields_desc = [ ByteField("length", 16),
                    BitEnumField("subtype", 3, 4, MPTCP_subtypes),
                    BitField("ipver", 4, 4),
                    ByteField("address_id", 0),
                    IPField("adv_addr", "0.0.0.0"),
                    XLongField("snd_mac", 0),] #conditional length

class MPTCP_AddAddrPort(MPOption):
    name = "Multipath TCP Add Address"
    subtype = 3
    subsubtype = 10<<4+3
    fields_desc = [ ByteField("length", 18),
                    BitEnumField("subtype", 3, 4, MPTCP_subtypes),
                    BitField("ipver", 4, 4),
                    ByteField("address_id", 0),
                    IPField("adv_addr", "0.0.0.0"),
                    ShortField("port",0),
                    XLongField("snd_mac", 0),] #conditional length
...
\end{lstlisting}

\subsubsection{Wireshark}
A fundamental tool used for the whole work about testing and developing MPTCP has been the widely popular open-source network packets analyzer Wireshark [\href{https://www.wireshark.org/}{href}]. The program provides MPTCP supports, but it couldn't recognize the new HMAC field in the ADD\_ADDR field during the development phase of such new feature. After the MPTCP code has been reviewed and merged, a small patch for Wireshark has been submitted in order to add support for ADD\_ADDR2. This patch allows to show the actual HMAC field when inspecting an ADD\_ADDR2 message, instead of providing the 8 raw bytes as an unknown component of the packet. Moreover, it allows to filter the capture file based on the HMAC field in ADD\_ADDR2. The patch has been merged into the official Wireshark repository [\href{https://github.com/wireshark/wireshark/commit/98fd9b852446ada31d47c158e022c545d0bc7f42}{href}].

\subsubsection{Linux SCTP}
While investigating the usage of Crypto-APIs in MPTCP, it was decided to inspect how the framework is used in similar scenarios in the latest Linux Kernel. The SCTP protocol, already mentioned in the introductory sections for its similarities with MPTCP, does adopt the Crypto library to perform hashing operations that require the \textit{crypto\_hash\_setkey()} (\href{http://lxr.free-electrons.com/source/net/sctp/auth.c#L751}{href}), in the same atomic running context of the MPTCP case. To verify this, Linux kernel 4.1.0 has been compiled with the option \textit{CONFIG\_DEBUG\_ATOMIC\_SLEEP} enabled and a SCTP connection has been started. The afore-mentioned option would provide a warning if a function that might potentially sleep is called inside an atomic section: the SCTP connection triggered such warning. An email has been sent to the official linux-crypto mailing-list for clarifications, and the issue with the current SCTP implementation has been acknowledged (\href{http://comments.gmane.org/gmane.linux.kernel.cryptoapi/17937}{href}).

\section{Experimental evaluation}
\label{exp}
The first Scapy script developed to exploit the ADD\_ADDR vulnerability and reproduce the hijacking attack in a simulation environment can be considered part of the experimental evaluation for the thesis work. However, this section focuses on the evaluation of the final products of the development process, mainly investigating the security enhancements and related performance implications introduced with the new ADD\_ADDR2 format and the other related patches.
Every single step of the development process has been verified with experimental tests.

\subsubsection{Version control}
The MPTCP version control works independently from the subsequent number of subflows and interfaces configuration at the hosts, so it has been tested in a single network scenario (the one shown in section \ref{envsetup}). All the combinations of version advertisements have been tested to make sure that version 1 is established only if available at both hosts. The sysctl value used to set the MPTCP version by the system administrator has been constrained to accept only 0 or 1 values for the time being. Moreover, tests have been setup to make sure that the version chosen for the very first MP\_CAPABLE packet is not changed upon retransmission. As explained in section \ref{retrocomp}, in order to cope with this case the sysctl value is read early on during initialization of the session and saved inside the \textit{tcp\_sock} data structure for the whole duration of the MPTCP connection. In order to make sure this solution works as expected, proper iptables rules have been set at localhost to drop the SYN/ACK packets from the server UML, thus triggering the SYN retransmission at the client UML: 

\begin{verbatim}
sudo iptables -I FORWARD -p tcp --tcp-flags ALL SYN,ACK -j DROP
\end{verbatim}

During the retransmission time, the sysctl command has been called to change the MPTCP version number, and it was indeed verified that such change didn't apply to the retransmitted packets; in fact, the updated MPTCP version number would be adopted only upon the creation of a new MPTCP connection. 
Another test related to the MPTCP version control was to establish a communication between two hosts running two different Kernel images, one with the MPTCP version control in place, and the second one with the older code that simply advertises version 0 and does not support ADD\_ADDR2. Interoperability has been confirmed, since the version agreement settles to 0 and the older version of ADD\_ADDR is used by both parties.

\subsubsection{Hashing function}
The modifications to the \textit{mptcp\_hmac\_sha1()} function required a deep understanding and evaluation of the correctness of the values produced by the HMAC-SHA1 algorithm. At first, to make sure that the enhanced version of the function was indeed working as expected, MPTCP sessions have been established with older version of the MPTCP kernel to verify that the HMAC values were verified properly by both implementations. Later, the OpenSSL tool have been used to calculate the HMAC-SHA1 value of any input key and message in hex format, in order to have a reference comparison tool to verify that the operations works as expected, for both the new hashing function and the old one. The Openssl tool is used with the following command in the terminal, with <hex message> and <hex key> to be replaced with the desired hex values:

\begin{verbatim}
echo -n <hex message> | xxd -r -p | \
openssl dgst -sha1 -mac HMAC -macopt hexkey:<hex key>
\end{verbatim}
 
The correct functioning of this command line has been verified by running some test cases found in \rfc{2202}.

The same tool was used to verify the correctness of the values retrieved using the Crypto-APIs in MPTCP. This framework turned out to be incompatible with atomic context executions, meaning that it can't be used while processing MPTCP options in the network stack. Nevertheless, and experimental evaluation of such configuration has been carried out, by using a preallocation mechanism to cope with the atomic execution problem (as explained in \ref{newhash}). 
A Kernel image has been compiled with the following built-it modules (other dependent Crypto modules are active but not shown in the list):
\begin{itemize}
  \item CONFIG\_CRYPTO=y
  \item CONFIG\_CRYPTO\_HASH=y
  \item CONFIG\_CRYPTO\_HMAC=y
  \item CONFIG\_CRYPTO\_SHA1=y
\end{itemize}
After this, the setup was operational. During the tests, no crashes due to a sleeping function in atomic context were observed when the preallocation technique was in place, since both the \textit{crypto\_alloc\_hash()} and the key placeholder alignment functions are executed out of atomic context. These results are limited to the adopted network scenario and UML configurations. In fact, the key alignment process was never triggered due to the fact that for the HMAC\_SHA1 algorithm in use for Crypto the alignment mask is equal to 0 (meaning that no alignment is actually needed). In order to force the execution of the alignment process, custom alignment mask values have been set, demonstrating the correct functioning of the alignment code in listing \ref{keyprealloc}. Nevertheless, such experimental evaluation of the Crypto framework is limited to the described setup, and further investigation is needed to inspect all the possible cases in which a sleeping function can be called within the framework, since this would cause deadlock in certain contexts of execution.

\subsubsection{ADD\_ADDR2 operations}
After having evaluated that both the version control and the extended hashing function work as expected, the next important step regards the tests on the new ADD\_ADDR2 format. The correct functioning of MPTCP with the new option have been verified in different configurations, mainly derived from the combinations of the following parameters:

\begin{itemize}
  \item Number of interfaces at the client and at the server (one or two);
  \item IP version in use (IPv4 or IPv6);
  \item Port advertisement in ADD\_ADDR2 (present or not present).
\end{itemize}

The resulting scenarios from combinations of these parameters have been tested during the development process. For the port advertisement checks, a random port value was inserted into the packets by using the experimental code as reported in section \ref{portad}.

The IPv4 testing involved two main configurations:
\begin{enumerate}
  \item Configuration almost identical to the model shown in listing \ref{clientconf}, for the case of the setup used in the ADD\_ADDR attack simulation. The client has two interfaces with IPv4 support while the server has a single available interface with IPv4 support;
  \item  Configuration in which the client has one interface while two interfaces are available at the server, using the IPv4 addresses shown in figure \ref{fig:network2}: it is fairly straightforward to modify the \textit{client.sh} and \textit{server.sh} scripts presented in the previous sections in order to attach two taps to the server and only one to the client (the scripts for this case are omitted). 
\end{enumerate}

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{images/Network_Scenario_2}
\caption{Network scenario, client one interface and server two interfaces (IPv4)}
\label{fig:network2}
\end{figure} 

It is important to note that in the first case, where the client has two interfaces, not only it advertises the second one using ADD\_ADDR(2), but it also soon after instantiate the new subflow with the server independently from the server's reaction to the received ADD\_ADDR(2) option: in the Linux Kernel implementation, the server would not start the creation of the subflow anyway. By providing the server with two interfaces instead, it is possible to actually trigger subflow establishment at the client exclusively thanks to the received ADD\_ADDR(2) from the server. In setting the second configuration not only the taps attached to the virtual machines have to be rearranged, but also the interface configuration within the virtual machines has to be modified to set the proper IP addresses and routing tables. The Ubuntu network configuration file in \textit{/etc/network/interfaces} for the server in this new scenario is reported here:

\begin{verbatim}
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet static
        address 10.2.1.2/24
        netmask 255.255.255.0
        gateway 10.2.1.1

auto eth1
iface eth1 inet static
        address 10.2.2.2/24
        netmask 255.255.255.0
        gateway 10.2.2.1
\end{verbatim}

Moreover, proper ip routing configurations have been set to direct the packet flows to the right gateways, as shown in the following extract from \textit{ip route} at the server:

\begin{verbatim}
10.2.1.0/24 dev eth0  proto kernel  scope link  src 10.2.1.2 
10.2.2.0/24 dev eth1  proto kernel  scope link  src 10.2.2.2 
\end{verbatim}
 
The two configurations reported so far were replicated for the IPv6 tests. In this case, slightly different changes were applied to the configuration files and scripts, but the final scenarios were again similar to the ones for IPv4, just with the updates IP addresses. The new \textit{client.sh} for the IPv6 scenario where the client has two interfaces is reported in listing \ref{clientsh6}, so that it is possible to inspect the new IPv6 compatible commands used to setup the tap interfaces, iptables, ip forwarding:

\begin{lstlisting}[language=bash, caption=\textit{client.sh for IPv6 setup}, label=clientsh6]
#!/bin/bash

USER=`whoami`

sudo tunctl -u $USER -t tap0
sudo tunctl -u $USER -t tap1

sudo ifconfig tap0 inet6 add 1000:1:1::1/64 up
sudo ifconfig tap1 inet6 add 1000:1:2::1/64 up

sudo sysctl -w net.ipv6.conf.all.forwarding=1
sudo ip6tables -t nat -A POSTROUTING -s 1000::0/8 ! -d 1000::0/8 -j MASQUERADE

sudo chmod 666 /dev/net/tun

./vmlinux ubda=fs_client mem=256M umid=umlA eth0=tuntap,tap0 eth1=tuntap,tap1

sudo tunctl -d tap0
sudo tunctl -d tap1

sudo ip6tables -t nat -D POSTROUTING -s 1000::0/8 ! -d 1000::0/8 -j MASQUERADE
\end{lstlisting}

The previous script is associated with the following network configuration inside the client UML machine:

\begin{verbatim}
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet6 static
	address 1000:1:1::2
	netmask 64
	gateway 1000:1:1::1

auto eth1
iface eth1 inet6 static
	address 1000:1:2::2
	netmask 64
	gateway 1000:1:2::1
\end{verbatim}

Appropriate route rules have been also set to achieve the desired flow redirection through the appropriate tap interfaces. Eventually, the IPv6 scenario involving a client with two interfaces and a server with a single interface, with the adopted IPv6 addresses, is represented in figure \ref{fig:netip6_1}:

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{images/Network_Scenario_6_1}
\caption{Network scenario, client two interfaces and server one interface (IPv6)}
\label{fig:netip6_1}
\end{figure} 

Finally, a second setup for IPv6 have been set, involving a client with a single interface and a server with two interfaces. All the implementation details about this scenario are omitted here, since they closely resemble the previous test beds.

All the scenarios, two with IPv4 and two with IPv6, were tested to ensure that the new ADD\_ADDR2 format works properly. For each and every scenario, port advertisement has been also tested. Since all the results were positive, only the outcome of a single scenario is reported in this paper, in appendix [add appendix reference]. Such appendix shows the capture file of an MPTCP connection involving the new ADD\_ADDR2 option sent from a server with two IPv4 interfaces to a client with a single IPv4 interface, with port advertisement enabled: it is possible to verify that the new subflow is started with MP\_JOIN from the client after receiving the ADD\_ADDR2 message, towards the advertised IP address and port.

\subsubsection{ADD\_ADDR2 and keys' eavesdrop}
After having tested the proper functioning of the new MPTCP implementation, this has been exposed to the very same attacking tool used to exploit the old ADD\_ADDR vulnerability. As expected, when the host using MPTCP version 1 receives the ADD\_ADDR message without the truncated HMAC field, it simply discards such packet and no subflow is originated, thus making the connection hijack impossible [appendix to capture file].

The same result is achieved by sending an ADD\_ADDR2 packet with random truncated HMAC, thus proving the HMAC verification process works as expected [appendix with capture file].

As a further evaluation of the new format, a modified version of the attacking script has been developed to eavesdrop the initial MPTCP keys exchanged in the MP\_CAPABLE options, thus being able to calculate the correct HMAC for ADD\_ADDR2 and carrying out the connection's hijack towards the updated MPTCP implementation [\href{https://github.com/fabriziodemaria/MPTCP-Exploit/tree/add-addr2-eav}{href}]. This attack is indeed the combination of ADD\_ADDR attack and keys' eavesdrop attack, both explained in the section about MPTCP security.
It is important to remind that such attack requires the attacker to be partially on-path eavesdropper to retrieve the above mentioned keys, which constitutes an important limitation for the attack, that is currently considered acceptable (see section \ref{keyseav}). Nevertheless, it is interesting to show the feasibility of this new kind of attack towards ADD\_ADDR2. The new Scapy script, acting in the same network configuration of section \ref{envsetup}, is very similar to the one used for exploiting the old ADD\_ADDR vulnerability with the only additional component capable of sniffing the keys in the SYN/ACK+MP\_CAPABLE option sent by the server to the client and using such key to compute a valid HMAC field for the forged ADD\_ADDR2 message. Such cryptographic function in the Scapy script is shown in listing \ref{pycrypto}, while the additional truncated HMAC value is added to the outgoing packet by using the modified Scapy class for ADD\_ADDR2 shown in listing \ref{scapy2}. In this case, as expected, the hijacking attack is still possible [appendix ref to capture file].

\begin{lstlisting}[language=Python, caption=\textit{HMAC calculation in Python}, label=pycrypto]
...
def genhmac_addaddr2(k1, k2, r1, r2):
    """Returns a HMAC-SHA1 with the concatenation of k1 and k2
    as key and the concatenation of r1 and r2 as message.
    k1, k2 are 64bits integers
    r1, r2 are 8bits and 32bits integers, respectively
    Return a 160bits integer
    """
    import hashlib
    import hmac
    import math

    key = xstr(k1).rjust(8,'\00') + xstr(k2).rjust(8,'\00')
    msg = xstr(r2).rjust(1,'\00') + xstr(r1).rjust(4,'\00')
    ...
    return xlong(hmac.new(key, msg=msg, digestmod=hashlib.sha1).digest())
...
\end{lstlisting}

\subsubsection{ADD\_ADDR(2) flooding}
A final performance evaluation has been executed on the new ADD\_ADDR2 format. The newly introduced HMAC value in the ADD\_ADDR2 packet would trigger cryptographic computations at the receiver. Such computations are highly optimized for fast execution and reduced CPU utilization, but they might represent a problem if triggered at a high rate. 
An example of the impact of the HMAC calculation for the MPTCP operations, it has been studied that this accounts for the 25\% of the overall CPU time spent in generating the SYN/ACK+MP\_JOIN packet [\href{http://inl.info.ucl.ac.be/system/files/phd-thesis_1.pdf}{href}].

This possibility to overload a host's CPU is now enabled with ADD\_ADDR2, where an attacker can forge ADD\_ADDR2 messages with random HMAC and flood the target, so that the latter has to call the \textit{mptcp\_hmac\_sha1()} function repeatedly. Two new Scapy scripts have been developed to perform such flooding with both ADD\_ADDR[\href{https://github.com/fabriziodemaria/MPTCP-Exploit/tree/add-addr-flood}{href}] and ADD\_ADDR2[\href{https://github.com/fabriziodemaria/MPTCP-Exploit/tree/add-addr-2-flood}{href}] so that it is possible to compare the difference in CPU load when the HMAC calculation is added to the flooding procedure. The \textit{main()} function of the script for the ADD\_ADDR2 flooding is reported in listing \ref{flood2}.

\begin{lstlisting}[language=Python, caption=\textit{Scapy flooding tool}, label=flood2]
def main():
    args = parse_args()

    ADVERTISED_IP = args.advertisedIP
    CLIENT_IP = args.clientIP
    SERVER_IP = args.serverIP
    CLIENT_IF = args.clientIf
    SERVER_IF = args.serverIf

    pktl = sniff(iface=CLIENT_IF, lfilter=lambda p: filter_source(p, CLIENT_IP), count=1)

    # Sending ADD_ADDR flood to client
    addaddrlist = []
    addaddrlist.append(forge_addaddr(ADVERTISED_IP, SERVER_IP, pktl[0][TCP].dport, CLIENT_IP, pktl[0][TCP].sport, (pktl[0][TCP].ack)+SEQUENCE_OFFSET, (pktl[0][TCP].seq)-SEQUENCE_OFFSET))
    
    for i in range (0, 1000):
        addaddrlist.append(addaddrlist[0].copy())
    for i in range (0, 10):
        print "Sending 1000 ADD_ADDR2 to client"
        send(addaddrlist, iface=CLIENT_IF, verbose=0)
    return
\end{lstlisting}

The command line used to call the script is identical to the one used in section \ref{reprattack} for the ADD\_ADDR attack simulation, and in this case it sends 10000 ADD\_ADDR2 packets with random HMAC value (such random value is present in \textit{forge\_addaddr()}, not shown in listing \ref{flood2}).

A separate Python script has been developed together with gnuplot in order to track and visualize the local CPU usage of the client virtual machine process over time [\href{https://github.com/fabriziodemaria/CPU_Monitor}{href}]. The tool simply samples the CPU usage percentage for the UML process from the command \textit{top}.
The test involved a \textit{netcat} communication between the client and the server, so that the average CPU usage is practically 0\% when no message is being exchanged. During the flooding procedure, ADD\_ADDR environment produces an average CPU usage of around 3.55\%; the ADD\_ADDR2 case shows an average CPU usage of around 3.67\% instead. 
The same test has been run five times to achieve better averaging. The experiment setup used two UMLs each using a single core of the eight i7 2GHz cores available in the physical machine. 256 MB of RAM was assigned to both virtual machines.
Scapy was able to forge and send ADD\_ADDR packets at a rate of 1183 packets per second, while the more complex ADD\_ADDR2 reached a rate of 1149, meaning a rate drop of around 3\%. Consistently, roughly the same performance difference has been observed in the CPU usage at the client in both configurations when flooded with ADD\_ADDR(2) messages.
This experiment gives a rough estimation of the impact brought by the HMAC field in case of flooding attacks. The final data shows a limited increase in CPU overload, not pronounced enough to claim that ADD\_ADDR2 introduces any new attacking vector.