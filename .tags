!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	0	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Fixing ADD  _ADDR	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^\\chapter{Fixing ADD\\_ADDR}$/;"	chapter	line:0
The ADD  _ADDR2 format	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^\\label{chap:addaddr2}$/;"	section	line:2
Implementing ADD  _ADDR2	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^Such format would require the attacker to know the key in order to forge a valid ADD\\_ADDR2 message, but such key is not exposed as in the case of the second possible solution previously described. Albeit, if the attacker is able to eavesdrop the keys during connection initiation it would be possible to exploit the same vulnerability even with the new address format. More experiments about this case are reported in section \\ref{exp}. Possible mitigations for such threat concerning keys' eavesdrop are explained in section \\ref{keyseav}. The keys' eavesdrop threat is a partial-time on-path eavesdrop, a category that is considered less critical in terms of security concerns. In fact, such keys' eavesdrop procedure in MPTCP has an almost identical counterpart in SCTP, when the SCTP-AUTH extension is used without pre-shared keys (as reported in \\rfc{5061}, \\textit{Stream Control Transmission Protocol (SCTP), Dynamic Address Reconfiguration}): the same security levels of SCTP would be reached in MPTCP by upgrading ADD\\_ADDR to ADD\\_ADDR2. Since SCTP is Standard Track, ADD\\_ADDR2 is indeed considered a sufficient modification of the MPTCP first design to reach the security levels required for the transition to Standard Track.$/;"	section	line:21
MPTCP in Linux	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^The current MPTCP patch added to the TCP stack in the Linux Kernel currently counts around 12000 lines of code (all the statistics about the code can be found at \\textit{https:\/\/multipath-tcp.org\/mptcp\\_stats\/index.html}). It is considered the reference implementation for MPTCP and it closely follows the RFC specifications. Moreover, a lot of effort has been put into the implementation design in order to make the new protocol acceptable for upstreaming to the official Linux Kernel. For such purpose, it is of paramount importance to keep the added complexity into the TCP stack as low as possible, in order not to jeopardize performance and stability of regular TCP. Nevertheless, high performance is expected for MPTCP. The main architectural concepts related to the control plane of the protocol are now explained, before introducing the modifications related to the new ADD\\_ADDR2 format as defined in \\rfc{6824bis-04}. $/;"	subsection	line:24
Truncated HMAC in ADD  _ADDR	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^The previous paragraphs presented an overview of the most important data structures and functions used in MPTCP to handle connection establishment and subflow management. The following sections contain an in-depth analysis of the ADD\\_ADDR functionality implemented in the Linux Kernel and how this was modified during the development of the new format ADD\\_ADDR2. In the following sections, the term \\textit{ADD\\_ADDR} is used to indicate the old format for the option, \\textit{ADD\\_ADDR2} is sued for the new format, while \\textit{ADD\\_ADDR(2)} addresses the option in general terms without referring to a specific version. Moreover, the term \\textit{HMAC} is often used to indicate the full \\textit{HMAC-SHA1} cryptographic function.$/;"	subsection	line:57
MPTCP version control	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^It is possible to notice that the code inside \\textit{mptcp\\_handle\\_add\\_addr()} is similar to the one used at the sender, with the local key used for HMAC computation instead of the remote key; moreover, for this code running at the receiver, the port value is present and processed if detected inside the ADD\\_ADDR(2) option, as it explained later in the following sections on port advertisement and hashing function's implementation.$/;"	subsection	line:190
Port advertisement	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^Despite all the precautions adopted in the process, using the Crypto library in the atomic context of the network stack is not a supported out of the box and it is not advisable to deploy such solution. The investigation about the usage of the Crypto API in the MPTCP implementation stopped at this point, but the entire work and related patches have been made available for future references. If the Crypto framework is updated to work in atomic context, then its usage in MPTCP would be the most likely the best option. Another possibility is to study all the possible paths and functions that can be reached by \\textit{crypto\\_hash\\_setkey()} to make sure that all the required memory allocations have been already taken care of before entering the atomic context. For now, the separate function \\textit{mptcp\\_hmac\\_sha1()} made available in MPTCP is considered the best solution for the cryptographic calculation within the new protocol.$/;"	subsection	line:389
IPv6 considerations	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^In line 9 it is possible to find the check regarding the presence of a valid port value in \\textit{opts->add\\_addr4.port}. This code will also add padding in case the port is written into the message. This solution have been adopted during the development work for the thesis in order to test random, hardcoded ports for both ADD\\_ADDR and ADD\\_ADDR2. However, the code to handle port writing in the outgoing ADD\\_ADDR(2) messages was not eventually merged into the official MPTCP implementation because of the added complexity that is not required at the moment, since no port is ever advertised with the current underlying code handling path management.$/;"	subsection	line:480
Overall contributions	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^\\end{lstlisting}$/;"	section	line:499
MPTCP Linux implementation	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^\\label{otherc}$/;"	subsubsection	line:503
RFC6824	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^The first implementation of ADD\\_ADDR2 for MPTCP has been also mentioned in the official MPTCP blog \\cite{blog}.$/;"	subsubsection	line:518
RFC7430	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^The new draft introduces changes that require future modification of the current work presented in the thesis, in order to meet the new specifications.$/;"	subsubsection	line:536
Nimai Scapy tool	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^A minor RFC Errata has been sent regarding the document 'Analysis of Residuals Threats and Possible Fixes for Multipath TCP (MPTCP)' (\\rfc{7430}), since a wrong classification has been assigned to the SYN\/JOIN attack in section 6. Such attack is not a \\textit{partial-time on-path eavesdropper} but the type is \\textit{partial-time on-path active attacker} \\cite{errata}.$/;"	subsubsection	line:539
Wireshark	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^\\end{lstlisting}$/;"	subsubsection	line:569
Hashing function	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^Another test related to the MPTCP version control was to establish a communication between two hosts running two different Linux Kernel images, one with the MPTCP version control in place, and the second one with the older code that simply advertises version 0 and does not support ADD\\_ADDR2. Interoperability has been confirmed, since the version agreement settles to 0 and the older version of ADD\\_ADDR is used by both parties.$/;"	subsubsection	line:590
ADD  _ADDR2 and keys  eavesdrop}
After having tested the proper functioning of the new MPTCP implementation, this has been exposed to the very same attacking tool used to exploit the old ADD_ADDR vulnerability. As expected, when the host using MPTCP version 1 receives the ADD_ADDR message without the truncated HMAC field, it simply discards such packet and no subflow is originated, thus making the connection hijack impossible [appendix to capture file].

The same result is achieved by sending an ADD_ADDR2 packet with random truncated HMAC, thus proving the HMAC verification process works as expected [appendix with capture file].

As a further evaluation of the new format, a modified version of the attacking script has been developed to eavesdrop the initial MPTCP keys exchanged in the MP_CAPABLE options, thus being able to calculate the correct HMAC for ADD_ADDR2 and carrying out the connection s hijack towards the updated MPTCP implementation cite  add-addr2-eav	/home/fabrizio/Documents/MPTCP_Security/chap_addaddr2.tex	/^All the scenarios, two involving IPv4 and two involving IPv6, were tested to ensure that the new ADD\\_ADDR2 format works properly. For each and every scenario, port advertisement has been also tested. All the results were positive, but only the outcome of a single scenario is reported in this paper, in appendix [add appendix reference]. Such appendix shows the capture file of an MPTCP connection involving the new ADD\\_ADDR2 option sent from a server with two IPv6 interfaces to a client with a single IPv6 interface, with port advertisement enabled: it is possible to verify that the new subflow is started with MP\\_JOIN from the client after receiving the ADD\\_ADDR2 message, and the advertised IP address and port are correctly used.$/;"	subsubsection	line:718
Introduction	/home/fabrizio/Documents/MPTCP_Security/chap_introduction.tex	/^\\chapter{Introduction}$/;"	chapter	line:0
Motivation	/home/fabrizio/Documents/MPTCP_Security/chap_introduction.tex	/^\\label{chap:introduction}$/;"	section	line:2
Benefits of MPTCP	/home/fabrizio/Documents/MPTCP_Security/chap_introduction.tex	/^Multipath TCP (MPTCP) is an ongoing project managed by the Internet Engineering Task Force (IETF), whose specifications have been published as Experimental Standard in January 2013 with the \\rfc{6824}; such protocol extends the current TCP to introduce multipathing capabilities, maintaining retro-compatibility at the end-points and undertaking a major endeavor to avoid disrupting of middleboxes' behavior. MPTPC can communicate with the application layer via standard TCP interface and it automatically splits data at the sender, it sends the data through different subflows (each being basically a regular TCP connection) according to the IP-addresses\/interfaces available at the hosts and finally reassembles the data at the receiver, in fact enabling multipathing.$/;"	subsection	line:37
Multipathing solutions	/home/fabrizio/Documents/MPTCP_Security/chap_introduction.tex	/^\\end{itemize}$/;"	subsection	line:58
Problem statement	/home/fabrizio/Documents/MPTCP_Security/chap_introduction.tex	/^The final goal of MPTCP is to replace the majority of the current TCP implementations, which is a very delicate process in which all the current TCP standards in terms of robustness, performance and security have to be maintained, if not improved. This paper is an evaluation of the security aspects of MPTCP, with an analysis of current threats and vulnerabilities affecting the protocol.$/;"	section	line:83
Methodology	/home/fabrizio/Documents/MPTCP_Security/chap_introduction.tex	/^\\end{itemize}$/;"	section	line:99
Document structure	/home/fabrizio/Documents/MPTCP_Security/chap_introduction.tex	/^The entire code developed during the stage, around 400 additions, was eventually merged into the official MPTCP repository for the Linux kernel. Some additional contributions have been performed in order to improve RFC documentation about the protocol and to upgrade related networking tools to be compatible with the new version of MPTCP.$/;"	subsection	line:108
Multipath TCP	/home/fabrizio/Documents/MPTCP_Security/chap_multipathtcp.tex	/^\\chapter{Multipath TCP}$/;"	chapter	line:0
Transmission Control Protocol  TCP 	/home/fabrizio/Documents/MPTCP_Security/chap_multipathtcp.tex	/^\\label{chap:multipathtcp}$/;"	section	line:2
Control plane	/home/fabrizio/Documents/MPTCP_Security/chap_multipathtcp.tex	/^\\end{figure}$/;"	subsection	line:101
MP  _CAPABLE	/home/fabrizio/Documents/MPTCP_Security/chap_multipathtcp.tex	/^The control plane for MPTCP takes into consideration all the options used in MPTCP to handle connection initiation, addition and removal of subflows, priority assignment to specific subflows, error handling via 'fallback' mechanism. These options are reported in the following subsections, adopting as reference documentation the \\rfc{6824}.$/;"	subsubsection	line:104
MP  _JOIN	/home/fabrizio/Documents/MPTCP_Security/chap_multipathtcp.tex	/^Regarding the hashing algorithm used to produce the tokens, this can be negotiated by using a portion of the flag bits inside the MP\\_CAPABLE option. In this paper, the SHA1 (and HMAC-SHA1 in case a key element is needed) is considered as the algorithm in use for the connections [ref to SHA1]. Note that the SHA1 algorithm produces a 160-bit resulting value, that might be then truncated to its leftmost 32 or 64 bits according to the different cases in the MPTCP operations, in order to fit in the \\textit{Options} field in the TCP header.$/;"	subsubsection	line:128
ADD  _ADDR	/home/fabrizio/Documents/MPTCP_Security/chap_multipathtcp.tex	/^These HMAC values are used to authenticate the participants in the subflow establishment, since both have to know the keys for the MPTCP connection in order to produce the right HMAC values. If the creation of the new subflow is not possible because A sends an unknown Token-B to host B or the HMAC material exchanged is not recognized by either hosts or the SYN\/ACK received at host A misses the MP\\_JOIN option, then the operation is stopped by sending a TCP RST.$/;"	subsubsection	line:163
REMOVE  _ADDR	/home/fabrizio/Documents/MPTCP_Security/chap_multipathtcp.tex	/^\\end{figure}$/;"	subsubsection	line:187
MP  _FASTCLOSE	/home/fabrizio/Documents/MPTCP_Security/chap_multipathtcp.tex	/^\\end{figure}$/;"	subsubsection	line:199
MP  _PRIO	/home/fabrizio/Documents/MPTCP_Security/chap_multipathtcp.tex	/^\\end{figure}$/;"	subsubsection	line:224
Data plane	/home/fabrizio/Documents/MPTCP_Security/chap_multipathtcp.tex	/^\\end{figure}$/;"	subsection	line:234
DSS option	/home/fabrizio/Documents/MPTCP_Security/chap_multipathtcp.tex	/^This part concerns the MPTCP option used to manage the data flow in a MPTCP connection, including how the payload byte stream is split and sent through different subflows and how the original order of the packets is provided at the receiver.$/;"	subsubsection	line:238
MPTCP deployment	/home/fabrizio/Documents/MPTCP_Security/chap_multipathtcp.tex	/^\\end{figure}$/;"	section	line:261
MPTCP security	/home/fabrizio/Documents/MPTCP_Security/chap_mptcpsecurity.tex	/^\\chapter{MPTCP security}$/;"	chapter	line:0
Threats analysis	/home/fabrizio/Documents/MPTCP_Security/chap_mptcpsecurity.tex	/^\\label{chap:mptcpsecurity}$/;"	section	line:2
Threats classifications	/home/fabrizio/Documents/MPTCP_Security/chap_mptcpsecurity.tex	/^Once the security requirements are clear, it follows a set of related problematics due to the way MPTCP is added to the regular TCP stack: the entire behavior of the protocol relies on the TCP \\textit{Options} field, which is of limited length of 40 bytes. This factor plays an important role in the definition of the security material to be exchanged during an MPTCP session (truncating the HMAC values and using shorter tokens are a common techniques). Moreover, TCP \\textit{Options} field has been designed to accept any custom protocol extending TCP and for security reasons many middleboxes would discard or modify packets containing unknown options. As a last point, MPTCP approach to subflow creation implies that a host cannot rely on other established subflows to support the addition of a new one (as reported in section 5.8 of \\rfc{RFC6182}); this last requirement follows the \\textit{break-before-make} property of MPTCP, that must be able to react to a subflow failure a posteriori by establishing new subflows and automatically sending again the undelivered data. All these considerations define the fundamental boundaries and the context in which the security design of MPTCP has to be developed to meet the requirements.$/;"	subsection	line:24
Minor threats	/home/fabrizio/Documents/MPTCP_Security/chap_mptcpsecurity.tex	/^There are no general thresholds to define when an attack can be considered a real threat according to the success rate, but this is an important factor to be studied in an attack analysis.$/;"	section	line:46
DoS attack on MP  _JOIN	/home/fabrizio/Documents/MPTCP_Security/chap_mptcpsecurity.tex	/^In this section are presented the minor residual threats under analysis by the IETF community at the time of writing, and all the related sections in this thesis closely follows such analysis as reported in the official document \\rfc{7430}. By labeling certain vulnerabilities as ``minor'' it means they are considered acceptable in the process of moving MPTCP towards Standard Track. They all fall into two main kinds of attacks: \\textit{flooding attacks} and \\textit{hijacking attacks}. $/;"	subsection	line:49
Keys eavesdrop	/home/fabrizio/Documents/MPTCP_Security/chap_mptcpsecurity.tex	/^A possible solution to this problem is to extend the MP\\_JOIN option format to include the information required to identify a specific request throughout the 3-way handshake, without requiring hosts to create associated states.$/;"	subsection	line:59
SSL  TLS and SSH	/home/fabrizio/Documents/MPTCP_Security/chap_mptcpsecurity.tex	/^In this proposal, four MP\\_JOIN messages are exchanged in total: the first two messages are used for authentication purposes (the hash chain values are transmitted there together with the required tokens), but the last two messages operate in a similar fashion with respect to the current MPTCP solution, carrying an HMAC value whose key depends on the original keys exchanged via the MP\\_CAPABLE option. In this way, eavesdropping the original keys is not enough to operate on the connection, but knowing the original keys is still required to validate subflows' creation.$/;"	subsubsection	line:84
An appendix	/home/fabrizio/Documents/MPTCP_Security/app_a.tex	/^\\chapter{An appendix}$/;"	chapter	line:0
Conclusions	/home/fabrizio/Documents/MPTCP_Security/chap_conclusions.tex	/^\\chapter{Conclusions}$/;"	chapter	line:0
Related work	/home/fabrizio/Documents/MPTCP_Security/chap_conclusions.tex	/^\\label{chap:conclusions}$/;"	section	line:2
Future work	/home/fabrizio/Documents/MPTCP_Security/chap_conclusions.tex	/^This thesis is focused on the development of the first implementation of ADD\\_ADDR2. No other implementations for such new format have been released yet at the time of writing, even if the specifications for it are currently available in RFC draft documents. This work is closely related to the underlying specifications elaborated by the IETF working group and MPTCP maintainers. From a more general perspective, all the research carried out on the security aspects of MPTCP can be considered related work and this includes middleboxes testing, which is a parallel project active at the Intel office in Lund (Sweden) where this thesis work has been performed. $/;"	section	line:5
ADD  _ADDR attack simulation	/home/fabrizio/Documents/MPTCP_Security/chap_addaddrattackexecution.tex	/^\\chapter{ADD\\_ADDR attack simulation}$/;"	chapter	line:0
Environment setup	/home/fabrizio/Documents/MPTCP_Security/chap_addaddrattackexecution.tex	/^\\label{chap:addaddrattackexecution}$/;"	section	line:2
Attack script	/home/fabrizio/Documents/MPTCP_Security/chap_addaddrattackexecution.tex	/^The python module \\textit{test\\_add\\_address.py} in the root of the GitHub repository follows the analysis in \\rfc{7430} to perform the various steps necessary to hijack the MPTCP connection. All the requirements and theoretical details about this procedure have been reported in section \\ref{theaddaddrattack}, and this section is limited to show and investigate the actual implementation of the attack.$/;"	section	line:57
