\chapter{Multipath TCP}
\label{chap:multipathtcp}

\section{Transmission Control Protocol (TCP)}
MPTCP is an extension of regular TCP, the ubiquitous protocol for highly reliable host-to-host communication in a packet-switched computer network. A proper introduction of the fundamentals of TCP is due.
TCP is a host-to-host communication protocol operating at a layer in between the application and the Internet Protocol. TCP abstracts all the details of the network connection to the application and it is used at the sender to split the application data stream into segments that can be efficiently routed through the network after being encapsulated into an IP packet. At the receiver, the segments are reassembled before being sent to the application layer.

The reasons why TCP became a de-facto standard in modern computer communication have been briefly mentioned in the introductory part of the paper. A more technical analysis shows that TCP maintains good levels of reliability for the connection independently from the lower layers it depends on for the raw transmission of bits. TCP is indeed able to handle possible data loss, data damaging, data duplication, out-of-order delivery of data. In order to do this, the data to be transmitted is split into a sequence of TCP segments, each containing an additional \textit{TCP header} with the information needed to operate the protocol functionalities at the nodes. Such functionalities are [\href{https://tools.ietf.org/html/rfc793}{ref}]:

\begin{itemize}
  \item \textit{Basic data transfer}: sending continuous stream of octets in each direction between its users, using the following 4-tuple to define the connection's endpoints: source IP address, source port, destination IP address, destination port. The IP address allows to route packets to the destination machine, while the port values direct the content of the packets to the right application within a host;
  \item \textit{Reliability}: in-order, reliable data transfer is achieved by adding a sequence number to each transmitted octet and using ACK signals and timeouts to possibly trigger retransmission of lost packets. TCP assures that no transmission errors will affect the delivery of the data if the network is not completely partitioned;
  \item \textit{Flow control}: the receiver can control the amount of data sent by the sender in a certain moment of the connection by returning a "window" value in the TCP header, so that it is possible to avoid buffer congestion;
  \item \textit{Multiplexing}: a single host is allowed to use multiple \textit{independent} TCP connections simultaneously thanks to the port value available in the protocol. This value, together with the host address assigned at the Internet communication layer, forms a socket, that is the actual endpoint of a TCP connection; note that \textit{multiplexing} is fundamentally different from \textit{multipathing}, the latter being the concept of exploiting multiple TCP connections for the same data transfer operation,
  \item \textit{Connections}: TCP initializes and maintains status information regarding each connection and the data stream between a pair of sockets in order to provide all its functionalities. Such data is initialized during a first handshake procedure, and released only upon connection termination. TCP is indeed known as a virtual-connection protocol;
  \item \textit{Precedence and Security}: these aspects refer to the possibility of prioritizing TCP connections and assign security properties to them. Both precedence and security can be configured by users, but default values are provided. For example, the checksumming operation for data integrity is optional in TCP.
\end{itemize}

As noted above, all TCP functionalities are made possible by processing the bits at the TCP header for each outgoing and incoming packet. The TCP header contains a structured set of fields, mostly static and predefined (with the exception of the TCP \textit{Option} field), so that at each position in the header corresponds a well known portion of the protocol data. The TCP header looks like the one in Figure \ref{fig:tcp_header}.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{images/tcp_header}
\caption{The TCP header format}
\label{fig:tcp_header}
\end{figure}

A component of the TCP header that is fundamental for MPTCP is the \textit{Options} field, which was introduced as a free space for future additions for the protocol. In this specific case, the TLV solution is adopted to process the data inside the field. "TLV" stands for \textit{type-length-value}, where the \textit{type} is the ID value uniquely identifying the option, the \textit{length} is the number of bytes of the option, whereas the \textit{value} represents the actual option content. This particular design allows to skip unknown options at the receiver (if type ID is not recognized) by simply checking the length value and moving the pointer accordingly. An important limitation for this field is that its total length cannot be more than 40 bytes [ref].

Regarding the basic operation of regular TCP, a connection is divided into three steps: \textit{connection establishment}, \textit{data transfer} and \textit{connection release}. Different fields in the TCP header are used for the different phases of the connection.

\subsubsection{Connection enstablishment}

During the connection establishment, a  three-way handshake is performed between the client and the server: the client sends a SYN packet to the port on which the server is listening; after that, the server answers with a SYN/ACK packet to acknowledge the connection request; as a third and final step, the client acknowledge the SYN/ACK packet by sending to the server an ACK packet. The three phases of this procedure justify the name "three-way handshake". In order to define the kind of TCP segment received, single-bit fields in the TCP header are used (for example, SYN and ACK flags are shown in figure \ref{fig:tcp_header}). 
The three-way handshake is important for various reasons: first of of all, both hosts declare their willingness to open the TCP connection using the addresses and ports indicated in the packets: the \textit{Source Port} and \textit{Destination Port}, together with the source and destination IP addresses provided in the IP header (not shown in figure \ref{fig:tcp_header}), are the means for identifying the two endpoints of the TCP connection. These fixed fields clearly shows the single-path fundamental design of TCP. 
Moreover, during the initial handshake both client and server declare the supported \textit{Options} and agree on the initial \textit{Sequence Number} values to be used for both directions of the connection.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/tcphandshake}
\caption{Basic TCP three-way handshake procedure}
\label{fig:tcphandshake}
\end{figure}

\subsubsection{Data transfer}
TCP splits the payload into multiple packets that are independently routed in the network and it is possible that they arrive at destination unordered, or that some of them are lost on the way. TCP is a protocol that offers bidirectional communication, so that the the receiver can communicate to the sender information for data transfer control. \textit{Sequence Number} and \textit{Acknowledgment Number} in the TCP header are used to number each transferred octet in the payload, so that the receiver can reorder them and acknowledge them in a cumulative way: by acknowledging sequence number X to the sender, the receiver is signaling that all packets up to but not including X have been received. This system, together with timeouts and sliding window mechanisms, allows for retransmission of lost packets, too. There is a flag bit in the header that is used to determine if a TCP segment is an ACK segment (also used during the initial handshake), meaning that the \textit{Acknowledgment Number} field in the current packet indeed represents the next \textit{Sequence Number} that the receiver is expecting. 
The \textit{Window} field is used to indicate to the sender the range of sequence numbers that the receiver is prepared to accept in a particular moment of the connection. In this way, the receiver can tune the the data flow and slow it down if the application is slow at consuming data and buffers tend to fill up quickly. The \textit{Checksum} field guarantees that data has not been modified on its way to the destination, intentionally or unintentionally.

\subsubsection{Connection release}
In normal cases, each participant terminates its end of the TCP connection by using a specific bit available in the TCP header: the FIN bit. The FIN message is indeed a way for a host to signal the request for connection termination, but such request has to be sent and acknowledged with a ACK for both endpoints before reaching the final tear down. Connection termination differs from the three-way handshake mechanism used for for connection establishment, and it can be better described as a pair of two-way handshakes between client and server.
There are also cases in which something goes wrong in the middle of the connection, compromising the correct functioning of the TCP protocol for data transfer; in these cases, the RST flag is used in a message to force abrupt closure of the connection.
 
\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/tcpclosure}
\caption{Normal TCP connection termination procedure}
\label{fig:tcpclosure}
\end{figure}

\section{MPTCP design}
\label{mptcpdesign}
MPTCP \textit{functional goals} are to increase resilience of the connectivity and efficiency of the resource usage by exploiting multiple paths (subflows) for the connection.
Similar goals can be found in other multipathing solutions as the ones described in section \ref{mptcp_alternatives}, but what is really unique about MPTCP design is the set of its \textit{compatibilities goals} [\href{https://tools.ietf.org/html/rfc6182}{ref}]:

\begin{itemize}
  \item \textit{Application compatibility} aims at instantiating a protocol that can be fully operational with no modifications for the applications using it. This means that the networking APIs and the overall service model of regular TCP have to be maintained with MPTCP; the entire MPTCP functioning is handled transparently by the underlying system. Such transparency must be maintained also in terms of throughput, resilience and security for the connection, that cannot be deteriorated with respect to the current TCP standards;
  \item \textit{Network compatibility} is a goal similar to the previous one, since MPTCP is supposed to work seamlessly with the current underlying network layer and the ones below it. The main reason still resides in the possibility of achieving a smooth wide deployment of the protocol on current infrastructure;
  \item \textit{Users compatibility} is a corollary to both network and application compatibility, which states that MPTCP flows must be fair to regular TCP connection in case of shard bottlenecks. If MPTCP would adopt a congestion control that is the same of the one for regular TCP, each subflow in an MPTCP connection would get the same amount of resources as a regular TCP connection and the overall bandwidth distribution would be unfair. Specific MPTCP congestion-control schemes have been studied to avoid such problems [refs].
\end{itemize}

All these compatibility requirements should justify the very fundamental decision of developing the new multipath protocol at the transport layer of the OSI architecture. Let's take into consideration the traditional TCP protocol stack and compare it to the new MPTCP stack (figure \ref{fig:stack}).
To achieve the required compatibility goals, changes had to be applied to the layers lower than the application layer, so that current applications do not have to be upgraded to make use of MPTCP; on the other side, the new protocol had to be placed at layers above the network layer: the network layer operates within the network infrastructure, a segment of the overall networking architecture that shouldn't be modified for MPTCP deployment. The transport layer, right above the network layer, is indeed the first component operating at the end systems: in order to get the smoothest possible widespread transition from TCP to MPTCP, the new protocol is intended to be deployed as a simple upgrade of the end systems' operating systems, with no modifications applied to the network infrastructure.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/stack}
\caption{The TCP and MPTCP protocol stacks}
\label{fig:stack}
\end{figure}

The choice of working at the transport layer is actually the only available option. Within that option, the choice of maintaining TCP as the fundamental operating protocol for MPTCP is still straightforward for similar compatibility reasons, since TCP is used in the vast majority of services and applications globally; for this very purpose, engineers decided to add all the required data used for MPTCP inside the TCP \textit{Option} field in the TCP header. In this way, MPTCP-aware systems can process the MPTCP options for multipathing, but if a system that is not MPTCP-aware receives a MPTCP connection request, it would simply discard the MPTCP options and treat such message as a plain TCP connection-request (thanks to the TLV design of TCP \textit{Options}, as explained in the previous section). 
MPTCP design maintains the behavior of the subflows to be compliant with regular TCP, while it is the end systems that take care of splitting the payload and send it through different paths as well as reassembling the same original data at the receiver. MPTCP subflows are identified by middleboxes as regular and independent TCP connections, carrying some additional options. If security policies at the middleboxes is not too restrictive against unknown options, MPTCP-unaware intermediate nodes would still be compatible with the new protocol. MPTCP is designed to be as compatible as possible with all the most common middleboxes of the Internet of today.
For what regards applications, they don't need to be changed either since MPTCP would be added into the network stack at the operating system level: MPTCP transparently splits the data buffered from the application layer and send it through different subflows, according to the number of available endpoints at the connected hosts. Communication with the application layer can be performed through the old TCP APIs, even if MPTCP specific options can be used by upgraded applications to take advantage of more advanced functionalities offered by MPTCP.

A functional decomposition of MPTCP brings up four core functions the protocol needs in order to operate:
\begin{itemize}
  \item \textit{Path management}: MPTCP has to provide a mechanism to detect and use multiple paths between two hosts;
  \item \textit{Packet scheduling}: MPTCP fragments the byte stream received from the application in order to transmit it through different subflows, adding the required sequenced mapping used to reconstruct the same byte stream at receiver;
  \item \textit{Subflow interface}: MPTCP uses TCP to send data within a single subflow;
  \item \textit{Congestion control}: a congestion control mechanism at the MPTCP connection layer is needed to make sure that MPTCP wouldn't starve a regular TCP flow in a shared bottleneck. The congestion control component of MPTCP implements the algorithms used to decide how to schedule the various data segments (which paths and which rate to adopt).
  \end{itemize}

All the MPTCP functions are implemented internally inside the specific operating system in use on the connected device, and they use a relatively compact set of TCP \textit{Options} to operate between two hosts. Technically, there is only a single generic MPTCP option, to which has been assigned the value 30 as the TCP "Option-Kind" identifier; at a lower level there are eight MPTCP option subtypes, each identified by a 4-bit identifier value (this classification, reported in figure \ref{fig:MPTCP_options}, references to \rfc{6824}). 

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{images/MPTCP_options}
\caption{The set of MPTCP options [RFC-6824]}
\label{fig:MPTCP_options}
\end{figure}

\subsection{Control plane}
The control plane for MPTCP takes into consideration all the options used in MPTCP to handle connection initiation, addition and removal of subflows, priority assignment to specific subflows, error handling via 'fallback' mechanism. These options are reported in the following subsections, adopting as reference documentation the \rfc{6824}.

\subsubsection{MP\_CAPABLE}
The connection initiation of an MPTCP connection is very similar to the standard TCP initial three-way handshake, involving a SYN, SYN/ACK and ACK exchange on a single path between host A and host B. In a regular TCP connection establishment these three packets are used to guarantee that both hosts have agreed on starting a TCP connection and also to exchange the two random initial sequence numbers that will be used to acknowledge data delivery for the two directions of the connection. Despite working as regular TCP, if MPTCP is enabled the SYN packet from host A will have a MP\_CAPABLE option in the \textit{Options} field of the TCP header. If the receiver host B is not MPTCP-compatible it will simply discard the MP\_CAPABLE option and proceeds instantiating a regular TCP connection.
In case both hosts are MPTCP-compatible, the MP\_CAPABLE option is inserted in the three packets of the initial handshake for two purposes: advertising that both hosts are indeed MPTCP-compatible and exchanging two 64-bit keys (Key-A and Key-B), according to the scheme in figure \ref{fig:mpcapable}.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/mpcapable}
\caption{MPTCP connection initiation}
\label{fig:mpcapable}
\end{figure}

These keys are sent in clear inside the MP\_CAPABLE option only during the initial handshake (and in the case of MP\_FASTCLOSE) and their purpose is to identify a specific MPTCP connection within a host (useful when associating a new subflow to an existing MPTCP connection, for example) and to provide shared security material that is used in MPTCP for authorization mechanisms (more on this later in this section). The \textit{Option} field in the TCP header can only be 40 bytes long, and it is not reserved for MPTCP options only. For this reason it is of primary importance to keep the amount of MPTCP related information as low as possible. In fact, the original 64-bit keys are exchanged only during initial handshake; subsequently, shorter 32-bit tokens (Token-A and Token-B) derived from such keys using a digest algorithm will be used to address a specific MPTCP connection, even if this procedure requires additional checks in case of collisions with other tokens already assigned to other MPTCP connections in the same machine (despite this being a very remote possibility). There is another fundamental motivation for using this mechanism of shorter tokens: the full keys, that represent security material used in the protocol for authentication purposes (for example in MP\_JOIN and ADD\_ADDR2 messages), are exposed only during connection setup in the MP\_CAPABLE messages; sending the full keys each time a new subflow has to be started would diminish the overall security of the protocol. Therefore, an implementation requires a mapping from each token to the corresponding connection, and in turn to the keys for the connection.

Regarding the hashing algorithm used to produce the tokens, this can be negotiated by using a portion of the flag bits inside the MP\_CAPABLE option. In this paper, the SHA1 (and HMAC-SHA1 in case a key element is needed) is considered as the algorithm in use for the connections [ref to SHA1]. Note that the SHA1 algorithm produces a 160-bit resulting value, that might be then truncated to its leftmost 32 or 64 bits according to the different cases in the MPTCP operations, in order to fit in the \textit{Options} field in the TCP header.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/opt_capable}
\caption{MP\_CAPABLE option}
\label{fig:opt_capable}
\end{figure}

\subsubsection{MP\_JOIN}
Suppose that after the first subflow is operational host A initiates a new subflow between one of its addresses and one of host B's addresses. Host A sends a TCP SYN packet to host B containing the MP\_JOIN option, which includes Token-B (the token derived from B's key) and a nonce value used to prevent replay attacks. An additional field in the MP\_JOIN option is called address ID, an identifier for the original addresses in use within a specific MPTCP connection. This additional value allows to refer to a certain address without the need to use the plain IP addresses value as identifier, which is very useful when middleboxes like NATs alter the IP header during the transit of the packets.
At the lower layers of the network, the SYN packet sent in this way looks like a legitimate request from host A to initiate a new TCP connection with host B, being the SYN packet the first of the regular TCP initial handshake. Host B processes such packet as a new MPTCP subflow request, and it uses the Token-B in the option to associate the request to the specific ongoing MPTCP connection with host A.

The handshake flow for MP\_JOIN includes HMAC values for authentication purposes, and it is structured as follow:
\begin{itemize}
  \item Token-B is added in the SYN packet from host A to host B in order to address a specific MPTCP connection; a random nonce (R-A) is also sent along;
  \begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/opt_join1}
\caption{MP\_JOIN option - SYN}
\label{fig:opt_join1}
\end{figure}
  \item Host B processes the request and sends back a truncated HMAC value calculated by using as \textit{key} the concatenation of Key-B followed by Key-A, and as the \textit{message} the concatenation of a new nonce generated at host B (R-B) and the one received from host A (R-A). R-B is also added to the option in a separate field, since it is needed by host A in the next step;
\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/opt_join2}
\caption{MP\_JOIN option - SYN/ACK}
\label{fig:opt_join2}
\end{figure}
  \item The last ACK form host A to host B contains the HMAC calculated using as key the concatenation of Key-A and Key-B, and as message the concatenation R-A and R-B. This time, the HMAC value is sent in its full length (160-bit).
\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/opt_join3}
\caption{MP\_JOIN option - ACK}
\label{fig:opt_join3}
\end{figure}
  \item Note that the HMAC in the ACK packet from host A to host B has to be acknowledged for the subflow to be finally established. In this case the third ACK is the only packet where the HMAC from host A is sent, and it has to be acknowledged or retransmitted if the fourth ACK from host B is not received.
\end{itemize}

These HMAC values are used to authenticate the participants in the subflow establishment, since both have to know the keys for the MPTCP connection in order to produce the right HMAC values. If the creation of the new subflow is not possible because A sends an unknown Token-B to host B or the HMAC material exchanged is not recognized by either hosts or the SYN/ACK received at host A misses the MP\_JOIN option, then the operation is stopped by sending a TCP RST.

%If everything works properly, the entire procedure of instantiating a MPTCP connection and add a subflow is represented with the example in figure \ref{fig:mptpcauth}. 
%\begin{figure}[!htb]
%\centering
%\includegraphics[width=0.75\textwidth]{images/mptcpauth}
%\caption{MPTCP authentication example}
%\label{fig:mptcpauth}
%\end{figure}

\subsubsection{ADD\_ADDR}
Even if a host can directly instantiate a new subflow using the MP\_JOIN option, another possibility is for the host to advertise an available address to the other machine, thus allowing the latter to instantiate the subflow.
This functionalities can be useful, for example, in a client-server configuration in which only the client is allowed to open new connections with the server: if a new interface becomes available at the server, the server itself can dynamically advertise it to the client which in turns can send the SYN+MP\_JOIN packet for subflow initiation.

This functionality is provided in MPTCP by the ADD\_ADDR option, that contains the additional address (and, optionally, port) to be advertised. To cope with NATs, the option also includes the previously mentioned address ID 8-bit integer, that has to be bounded to the new address used to create the subflow.
The ADD\_ADDR option is treated as a soft component of the overall MPTCP implementation, with no need to be sent reliably and/or be acknowledged by the receiver. The option can be added to any packet in the MPTCP connection if there is enough space in the \textit{Option} field of the TCP header, with no guarantee that such option will be received or that the receiver will indeed use the advertised information to start a new subflow. This low priority assigned to ADD\_ADDR is reasonable since the malfunctioning of this option would not break the overall data transmission, but it might only cause a missed opportunity for better multipath exploitation. For similar reasons, there is no need to ensure a proper ordering for ADD\_ADDR and REMOVE\_ADDR at the receiver (REMOVE\_ADDR, explained in the following section, is similar to ADD\_ADDR but it indicates which subflow to shut down during an MPTCP session). 

The content of the ADD\_ADDR option is shown in figure \ref{fig:addaddropt}. The IPVer field indicates if the advertised address is of kind IPv4 or IPv6, while the other fields contain the address ID, advertised IP Address and optionally the advertised port.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/addaddropt}
\caption{ADD\_ADDR option}
\label{fig:addaddropt}
\end{figure}

\subsubsection{REMOVE\_ADDR}
If an address becomes unavailable during a MPTCP connection, the affected host should announce this so that any subflow currently using that address can be terminated. For security purposes, when a REMOVE\_ADDR is received, a test is performed to make sure that the address is not available anymore, by sending a TCP keepalive on the path.
The address ID is used to identify the path to be shut down, so that no explicit address is needed (and no IP address field is in fact present in the REMOVE\_ADDR option): in this way the option works through NATs. 
A subflow that is working properly must not use this option to close the connection when the data transfer is complete, but a FIN exchange similar to regular TCP is performed instead.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/opt_remove}
\caption{REMOVE\_ADDR option}
\label{fig:opt_remove}
\end{figure}

\subsubsection{MP\_FASTCLOSE}
This option can be thought as the MPTCP-level counterpart of the RST signal for the regular TCP connections: it permits the abrupt closure of the whole MPTCP connection. The RST signals couldn't trigger such behavior, since they are confined to work against a single TCP flow (i.e. an MPTCP subflow).

This option can be sent by host A to trigger MPTCP closure at host B. In this case, MP\_FASTCLOSE must contain the value of Key-B. When host B receives the option through one of the subflows, it will send a TCP RST answer via the same subflow and then tears down all the subflows. Host A is waiting for the TCP RST answer from host B before tearing down all the subflows. This generic behavior might change slightly if both hosts send an MP\_FASTCLOSE at the same time, or if the awaited TCP RST signal is not received within a certain timeout (this would trigger a limited number of retransmissions for this option).

\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/opt_fastclose}
\caption{MP\_FASTCLOSE option}
\label{fig:opt_fastclose}
\end{figure}

\subsubsection{MP\_FAIL}
There are various cases in which things might go wrong for a MPTCP connection, and the right procedure to handle such cases is to 'fallback', meaning either switching to regular TCP or removing the subflow generating the issue. The first solution has been already encountered for the MP\_CAPABLE exchange, where TCP fallback is guaranteed in case a host is not MPTCP compatible. Similarly, subflow addition will be blocked if anything goes wrong in the MP\_JOIN packets' exchange procedure. However, there are other cases in which problems occur after this initiation phases, on regular packets. 
As explained later in section \ref{dataplane}, data acknowledgment in MPTCP requires a DSS option present in the ACK packets. If that option is missing, the path is not considered MPTCP capable. The consequences are different according to the subflow: if the affected path is the first instantiated with the MP\_CAPABLE option then it must fallback to regular TCP; any other subflow showing such problem would be closed with a RST message. 
The fallback procedure can be required at any point during the connection if a middlebox modifies the data stream. This case would be detected thanks to the checksum properties of MPTCP data transfer. If checksum fails, all data from the failing segment onwards cannot be trusted anymore. When this happens to a subflow, it has to be immediately closed with a RST and a MP\_FAIL option that indicates the data sequence number that failed the checksum: such option indeed contains a single main field storing the full 64-bit sequence number. The receiver can then avoid to acknowledge untrusted data, that will be sent again through a different subflow following the retransmission features of the data plane part of the MPTCP protocol. 

\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/opt_fail}
\caption{MP\_FAIL option}
\label{fig:opt_fail}
\end{figure}

\subsubsection{MP\_PRIO}
It is possible to indicate if a path has to be used regularly or just as backup in case there no other available regular paths. This preference can be advertised at subflow creation via a flag in the MP\_JOIN option, but it is also possible to signal a priority change at any time during the MPTCP connection. In fact, it is enough to send the MP\_PRIO option to the targeted subflow to signal the other host about the change; it is also possible to add an address ID to explicitly target a specific subflow that might be different with respect to the one used to send the MP\_PRIO option. This option is only sent from the receiver to the sender, even if the sender can discard such priority preference for any reasons. 

\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/opt_prio}
\caption{MP\_PRIO option}
\label{fig:opt_prio}
\end{figure}

\subsection{Data plane}
\label{dataplane}
This part concerns the MPTCP option used to manage the data flow in a MPTCP connection, including how the payload byte stream is split and sent through different subflows and how the original order of the packets is provided at the receiver.

\subsubsection{DSS option}
\label{dss}
The DSS options contains all the fields needed to maintain ordering information about the octet sent during the MPTCP session, so that the correct data received from (possibly) multiple subflows can be reassembled at the receiver. DSS option also includes the DATA-ACK flag for acknowledgement purposes and the equivalent of a TCP FIN for the overall MPTCP connection, meaning that the current mapping covers the final data from the sender (figure \ref{fig:mptcp_fin}). Finally, this option might also include the checksum field to perform integrity checks on the payload (if this was enabled when instantiating the connection via the MP\_CAPABLE option).

\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/mptcp_fin}
\caption{Closing a MPTCP connection}
\label{fig:mptcp_fin}
\end{figure}

Regarding the data sequence mapping in MPTCP, the general idea is to maintain TCP-compliant and independent sequence numbers for the single subflows, while using a mapping functionality at the MPTCP-level, provided by the DSS option, to properly rearrange the data at the receiver and guarantee in-order and reliable overall transmission as in the case of legacy TCP. The alternative approach would have been to have a single MPTCP-level sequence number used for the entire set of subflows, meaning that a single subflow inspected by middleboxes would look like a TCP connections with holes in the payload delivery; this could trigger unwanted behaviors that would be against the compatibility goals of MPTCP.

The DSS option achieves data sequence mapping with the combination of three fields: for a certain number of bytes (indicated in the \textit{Data-Level Length} field) and starting from the reported subflow sequence number (\textit{Subflow Sequence Number} field), the TCP-level sequence maps to the MPTCP-level sequence with starting value indicated in the \textit{Data Sequence Number} field.
The DATA-ACK flag works as regular TCP ACK flag, but it refers to the MPTCP-level acknowledgment of the received data. Note that subflow-level acknowledgement is still provided by regular TCP, but a second acknowledgement mechanism at connection-level is desired, since there might be cases in which data that has been acknowledged at the subflow-level can still be discarded in the buffers before reaching the application. By following the core principles of MPTCP, retransmission of packets can occur at different paths.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.75\textwidth]{images/opt_dss}
\caption{DSS option}
\label{fig:opt_dss}
\end{figure}

\section{MPTCP deployment}
%Add some images for middleboxes or deployment status graphs
A seamless transition towards MPTCP on current infrastructures is a major requirement for MTPCP deployment.
Despite the big effort in designing a protocol compliant with strict compatibility requirements, assuring correct functioning in all the current network scenarios is not a viable possibility for MPTCP. The main problematics are related to unwanted behavior of middleboxes processing unknown MPTCP packets, but that is not the only aspect currently limiting the deployment status of the new protocol. MPTCP has to guarantee the same levels of reliability, performance and security of regular TCP (including the cases in which the fallback mechanism is adopted to switch to plain TCP). 
As reported in the following sections, MPTCP includes various mechanisms to cope with the most common middleboxes of today's Internet, including the possibility to detect when external boxes operate on the traffic in a way that cannot be handled by MPTCP thus triggering fallback to regular TCP.

\subsection{Middleboxes compatibility}
The Internet at its core was designed to provide end-to-end connectivity across an infrastructure of interconnected routers. Nevertheless, the growing rate of adoption and increasing complexity of the Internet brought up a wide set of new requirements directly involving the intermediate stages of the communication rather then the end-hosts. Such requirements include the need to instantiate protection techniques against potential attacks, more flexibility in content delivery, caching for more efficient communication; they can even be more specific, like the need to rapidly overcome the IPv4 addresses depletion. Middleboxes are pieces of equipment that operate on the network traffic to meet these requirements. The most common middleboxes are NATs, proxies and firewalls, but nowadays there is a huge variety of deployed middleboxes that inevitably break the end-to-end principle of the Internet. Despite their usage is often required, they are more or less intrusive at different layers according to where they operate within the OSI architectural model, thus causing malfunctioning of many protocols, and MPTCP is no exception. Middleboxes can indeed inspect packets, re-route them, drop them, split them into multiple fragments, and even modify single fields in packets' headers (like rewriting sequence number or removing TCP options) as well as change their payload.

The various operations and purposes of middleboxes are many and often mixed together to achieve more complex policies, and it is very common that different kind of operations are performed inside the same physical machine. Despite this, it is possible to define a set of most common distinct middleboxes' operations [\href{https://queue.acm.org/detail.cfm?id=2591369}{href}], reported in the following sections.

\subsubsection{Firewalls}
A simple example can be the case of a standard firewall that is not MPTCP-aware and its default policy is set to "deny". In this case, all the traffic is blocked apart from the connections and/or packets compliant with the set of custom rules explicitly configured in the firewall. In this case, specific rules for MPTCP must be added to support the new protocol, and this might cause a considerable effort for network maintainers. For example, it is often not straightforward to operate on legacy firewall configurations for big companies with many access points.

A more subtle problem with firewalls might be derived by the fact that they can sometimes manipulate the sequence numbers of a TCP connection, thus shifting the sequence number space with respect to the initial value in use by the end-hosts. This feature has been introduced in the past to improve security with older TCP/IP stacks, but the concept could have disrupted MPTCP mapping between subflow sequence number and MPTCP-level sequence number. To avoid such problems, MPTCP is designed so that the mapping in the DSS option is using relative values compared to the initial sequence number and correct functioning is not jeopardized but changes of the absolute values performed by the firewalls.

Yet another case concerns firewalls that remove unknown TCP options for security purposes. If such operation is symmetric, TCP segments would lose the MP\_CAPABLE option and fallback seamlessly to regular TCP. However, there are middleboxes that operates asymmetrically thus removing unknown TCP options only inside non-SYN segments. To cope with this, MPTCP requires that for the first window of data, each segment must include an MPTCP option, otherwise fallback is performed [\href{http://conferences.sigcomm.org/co-next/2013/workshops/HotMiddlebox/program/p37.pdf}{href}].

\subsubsection{NATs}
Another ubiquitous piece of equipment is the "Network Address Translation" (NAT). As the name suggests, NATs modify the IP addresses within the packets on their way towards the destination. The main purpose is to group addresses of an internal private network and map them to a single public address before forwarding the traffic to the Internet. NATs are also able to redirect the response from the Internet to the right host in the internal network.
This procedure became very common with the depletion of IPv4 addresses, since in many cases the address space assigned to a outer portion of the Internet is not large enough to cover the number of hosts willing to acquire connectivity. 
NATs turned out to be a very effective way to temporarily solve the problem of IPv4 addresses, but their mode of operation is intrusive at the network and transport layer, since the IP addresses are not fixed anymore.
For example, even if NATs use internal tables to keep track of the mappings and are able to redirect replies from the external network to the right internal host, it is no more possible for the external hosts to instantiate a new connection with a specific host residing behind a NAT. This is true also in MPTCP, such that a server often cannot open a new subflow with a client if the latter is behind a NAT, even if a valid MPTCP session between client and server is already active. This is one of the main use cases in which an ADD\_ADDR message can be sent on live subflows in order to trigger a new subflow connection request from the other side.
Moreover, to cope with NATs that might be operational on the paths and might change the source address of the packets, MPTCP options refer to addresses by using an address ID instead of the plain IP address value. 

\subsubsection{Segment splitting and coalescing}
There are middleboxes that split segments on the Internet as required by the MTU (maximum transmission unit). This means that the payload of a single TCP packet can be scattered across multiple smaller TCP packets and regrouped back together by using the appropriate TCP fields in the header. This operation usually copies TCP options unchanged into each of the smaller packets that are generated. By simply adopting data sequence numbers for the overall MPTCP-level data transfer, the receiver might receive different packets with identical data sequence numbers and it would be unable to reconstruct the original data. MPTCP takes care of segment splitting and coalescing by mapping the subflow-level TCP sequence number with the MPTCP-level sequence, by providing both the beginning (with respect to the subflow sequence number) and the length of the of the data-sequence mapping (as explained in section \ref{dss}).
MPTCP would work also in the more uncommon cases in which segment splitters copy the original TCP option in only one of the generated smaller segments. If the first data-segment does not contain an MPTCP option, fallback to regular TCP is performed, otherwise MPTCP would work seamlessly even under these circumstances [\href{http://conferences.sigcomm.org/co-next/2013/workshops/HotMiddlebox/program/p37.pdf}{href}].

\subsubsection{Application-level gateways}
There are middleboxes that operate at higher layer in OSI model, modifying the payload of the packets: adding and removing bytes can change the boundaries of the data-sequence mapping and MPTCP information about it would become inconsistent. The only way to cope with this case is to fallback to regular TCP. In order to that, MPTCP has to detect when the payload has been changed by middleboxes and that is the main reason for which the checksum field has been added inside each and every DSS option. The checksum calculation is optional in MPTCP and can be negotiated during connection establishment with a flag in the MP\_CAPABLE option. Nevertheless, it is recommended for operations on the open Internet.

\subsection{Deployment status}
MPTCP proves to be a major TCP extension, and in this regards its design required a lot of efforts and several interconnected research projects. The European Commission funded the work at the Université catholique de Louvain with the FP7 Trilogy project in 2007 [\href{http://www.trilogy-project.org/}{href}], followed by CHANGE [\href{http://www.change-project.eu/}{href}] and Trilogy 2 [\href{http://trilogy2.it.uc3m.es/}{href}]. Fundings have been instantiated by Google and Nokia, too [\href{https://multipath-tcp.org/pmwiki.php}{href}]. 
By analyzing the main steps in MPTCP evolution it is possible to detect the big interested in the protocol: six month after the Experimental Standard for MPTCP has been published in January 2013 by the IETF, there were already three major independent MPTCP implementations other than the Linux kernel implementation [\href{https://datatracker.ietf.org/doc/draft-eardley-mptcp-implementations-survey/?include_text=1}{href}], including a FreeBSD implementation from Swinburne University of Technology [\href{http://lists.freebsd.org/pipermail/freebsd-net/2013-March/034882.html}{href}] and a NetScalar Firmware implementation from Citrix Systems [\href{https://www.citrix.com/blogs/2013/05/28/maximize-mobile-user-experience-with-netscaler-multipath-tcp/}{href}].
Moreover, recent versions of MPTCP (from 0.89.5) are now compatible with Android (with some limitations), and many porting projects have been developed to test older versions of MPTCP on various Android devices [\href{https://multipath-tcp.org/pmwiki.php?n=Users.Android}{href}].
As of June 2015, a Solaris implementation is reportedly under development by Oracle [\href{https://mailarchive.ietf.org/arch/msg/multipathtcp/ugMIu566McQMn8YCju-CTjW9beY}{href}].
All these implementations follows the standard RFC documentation for MPTCP, and they have shown good interoperability capabilities while being tested with the reference MPTCP-compatible Linux kernel, especially for what regards the core MPTCP signaling messages (secondary MPTCP features, like ADD\_ADDR address advertisement, are not always implemented [\href{https://datatracker.ietf.org/doc/draft-eardley-mptcp-implementations-survey/?include_text=1}{href}]).

The very first large scale commercial deployment of MPTCP dates back to 2013, when Apple introduced the new protocol in iOS7 to work with the intelligent personal assistant Siri. Apple's mobile operating system implements MPTCP as in \rfc{6824} (excluding some features) in order to use cellular data subflow in case the Wi-Fi connectivity becomes unavailable during a Siri request processing [\href{https://support.apple.com/en-us/HT201373}{href}]. This is indeed the first example of wide adoption of MPTCP over the Internet even if limited to a specific Apple service connecting to proprietary servers. Nevertheless, the news was helpful in spreading the awareness about the protocol to a more consumer-oriented audience. Apple also added MPTCP capabilities to Mac OS X 10.10 in October 16, 2014 [\href{http://labs.neohapsis.com/2014/10/20/mptcp-roams-free-by-default-os-x-yosemite/}{href}], proving to be very active in developing and testing MPTCP.

In studying the protocol's deployment process, it is very important to analyze the relation between costs and benefits that MPTCP would bring to each and every group of MPTCP stakeholders.
The success of MPTCP depends on its deployment, and its deployment strongly depends on endpoints. It has already been mentioned the interest shown by OS authors towards MPTCP, which naturally fits the pre-deployment stage. But eventually it will be the end-users to decide the future for MPTCP: they are the ones directly accessing the biggest part of MPTCP benefits as described in section \ref{benefits}. Without considering middleboxes interference, there is conceptually no need for technical modifications at the intermediate infrastructure to make MPTCP available at the end-users. Nevertheless, connectivity providers (ISPs) still represent an important part of the entire set of stakeholders that might benefit from MPTCP wide adoption: multipathing can directly improve resource utilization and congestion bottlenecks within the overall infrastructure, but it can also be seen by ISPs as an enabler of new business models, since end users might show an increased interest in multihoming solutions [\href{https://books.google.de/books?id=ECBxhiURlKYC&pg=PA23&lpg=PA23&dq=mptcp+deployment&source=bl&ots=_cvPxxdH6K&sig=P5AlF9bU_iE3C63HfXvgD77tUg8&hl=en&sa=X&ved=0ahUKEwi0wMnuscfKAhUB1hQKHT0cARsQ6AEIUzAI#v=onepage&q&f=false}{href}]. End users' feedback and ISPs' feedback for MPTCP do and will drive the interest of infrastructure vendors to better support the protocol or not inside their middleboxes. 
Yet another case study involves data infrastructure maintainers, that can be considered a smaller but important subset of end users. In this case it is fundamental the value that MPTCP can bring to data centers of today as well as the possibilities enabled by MPTCP for the design of the data centers of the future [\href{http://conferences.sigcomm.org/sigcomm/2011/papers/sigcomm/p266.pdf}{href}].

All these considerations are difficult to analyze in the real world, thus making it hard to predict future trends for MPTCP adoption. Current applications of MPTCP rarely detach from experimental branches and little is known on how the new protocol would behave in the Internet if globally enabled. Excluding the MPTCP usage for Siri and Apple's servers, the closest example of real world usage of MPTCP has been setup and analyzed by the Université catholique de Louvain: the experiment consisted in collecting a dataset about traffic usage for an MPTCP-enabled Web server exposed to the open Internet in November 2014 [\href{http://inl.info.ucl.ac.be/system/files/paper_8.pdf}{href}]. The Web server was running the stable version 0.89 of the MPTCP implementation in the Linux Kernel and using a single physical network interface supporting both IPv4 and IPv6. As for the content, the Web server was hosting the Multipath TCP implementation in the Linux kernel, a common destination for early adopters of the new protocol. After on week of monitoring, the dataset included around 122 millions of TCP packets destined to the Web server and roughly a quarter of those were MPTCP packets for a total of 5098 observed MPTCP connections. 
An interesting fact about the analyzed ADD\_ADDR packets showed that clients advertised mostly private addresses (79\% of the IPv4 advertised addresses), thus confirming the importance of MPTCP being able to pass through NATs. 
The final evaluation for this experiment demonstrated that MPTCP works properly in the open Internet if the Application Level Gateways (ALGsaddress ID) are handled by protecting the payload using the checksum in the DSS option (a feature enabled on server side for the entire set of 5098 MPTCP connections).

For what regards the current numbers MPTCP-enabled clients and servers around the world, such information is not easy to retrieve. For this purpose, a service has been built by NICTA (Sidney) and Simula Research Laboratory (Oslo), to scan the most common Web servers for the websites retrieved from the Alexa Top 1M list and check for MPTCP compatibility. This test is run between once a day and once a week, so that a live dashboard showing the retrieved data over time is maintained [\href{https://academic-network-security.research.nicta.com.au/mptcp/deployment/}{href}]. According to their latest results, the rate of adoption of MPTCP from the scanned IP addresses and domains is around 0.1\% [\href{http://www.nicta.com.au/publications/research-publications/?pid=8791}{href}], showing that the current status is far from large scale adoption.